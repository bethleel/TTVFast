        - # Translation of David Hernandez's nbody.c for integrating hiercharical
        - # system with BH15 integrator.  Please cite Hernandez & Bertschinger (2015)
        - # if using this in a paper.
        - 
        - const YEAR  = 365.242
        - const GNEWT = 39.4845/YEAR^2
        - const NDIM  = 3
        - const KEPLER_TOL = 1e-8
        - const third = 1./3.
        - const alpha0 = 0.0
        - include("kepler_step.jl")
        - include("init_nbody.jl")
        - const pxpr0 = zeros(Float64,3);const  pxpa0=zeros(Float64,3);const  pxpk=zeros(Float64,3);const  pxps=zeros(Float64,3);const  pxpbeta=zeros(Float64,3)
        - const dxdr0 = zeros(Float64,3);const  dxda0=zeros(Float64,3);const  dxdk=zeros(Float64,3);const  dxdv0 =zeros(Float64,3)
        - const prvpr0 = zeros(Float64,3);const  prvpa0=zeros(Float64,3);const  prvpk=zeros(Float64,3);const  prvps=zeros(Float64,3);const  prvpbeta=zeros(Float64,3)
        - const drvdr0 = zeros(Float64,3);const  drvda0=zeros(Float64,3);const  drvdk=zeros(Float64,3);const  drvdv0=zeros(Float64,3)
        - const vtmp = zeros(Float64,3);const  dvdr0 = zeros(Float64,3);const  dvda0=zeros(Float64,3);const  dvdv0=zeros(Float64,3);const  dvdk=zeros(Float64,3)
        - 
        - const state0 = zeros(Float64,12); state = zeros(Float64,12); delx = zeros(Float64,NDIM); delv = zeros(Float64,NDIM); xcm = zeros(Float64,NDIM); vcm = zeros(Float64,NDIM)
        - 
        - function ttv!(n::Int64,t0::Float64,h::Float64,tmax::Float64,elements::Array{Float64,2},tt::Array{Float64,2},count::Array{Int64,1},dtdq0::Array{Float64,4})
        - #fcons = open("fcons.txt","w");
        3 m=zeros(Float64,n)
        3 x=zeros(Float64,NDIM,n)
        3 v=zeros(Float64,NDIM,n)
        - # Fill the transit-timing & jacobian arrays with zeros:
        3 fill!(tt,0.0)
        3 fill!(dtdq0,0.0)
        - # Counter for transits of each planet:
        3 fill!(count,0)
        3 for i=1:n
       24   m[i] = elements[i,1]
        - end
        - # Initialize the N-body problem using nested hierarchy of Keplerians:
        3 x,v = init_nbody(elements,t0,n)
        3 xprior = copy(x)
        3 vprior = copy(v)
        - # Set the time to the initial time:
        3 t = t0
        - # Set step counter to zero:
        3 istep = 0
        - # Jacobian for each step (7- 6 elements+mass, n_planets, 7 - 6 elements+mass, n planets):
        - #jac_step = zeros(Float64,7*n,7*n)
        3 jac_prior = zeros(Float64,7*n,7*n)
        3 dtdq = zeros(Float64,7,n)
        - # Initialize the Jacobian to the identity matrix:
        3 jac_step = eye(Float64,7*n)
        - 
        - # Save the g function, which computes the relative sky velocity dotted with relative position
        - # between the planets and star:
        3 gsave = zeros(Float64,n)
        - # Loop over time steps:
        3 dt::Float64 = 0.0
        3 gi = 0.0
        3 while t < t0+tmax
        -   # Carry out a phi^2 mapping step:
        - #  phi2!(x,v,h,m,n)
    24003   dh17!(x,v,h,m,n,jac_step)
        -   # Check to see if a transit may have occured.  Sky is x-y plane; line of sight is z.
        -   # Star is body 1; planets are 2-nbody (note that this could be modified to see if
        -   # any body transits another body):
    24003   for i=2:n
        -     # Compute the relative sky velocity dotted with position:
   168021     gi = g!(i,1,x,v)
   168021     ri = sqrt(x[1,i]^2+x[2,i]^2+x[3,i]^2)
        -     # See if sign switches, and if planet is in front of star (by a good amount):
   168021     if gi > 0 && gsave[i] < 0 && x[3,i] > 0.25*ri
        -       # A transit has occurred between the time steps.
        -       # Approximate the planet-star motion as a Keplerian, weighting over timestep:
     3108       count[i] += 1
        - #      tt[i,count[i]]=t+findtransit!(i,h,gi,gsave[i],m,xprior,vprior,x,v)
     3108       dt = -gsave[i]*h/(gi-gsave[i])
        - #      dt = findtransit2!(1,i,h,dt,m,xprior,vprior)
     3108       xtransit = copy(xprior)
     3108       vtransit = copy(vprior)
     3108       jac_transit = copy(jac_prior)
     3108       dt = findtransit2!(1,i,h,dt,m,xtransit,vtransit,jac_transit,dtdq) # 20%
     3108       tt[i,count[i]]=t+dt
        -       # Save for posterity:
     3108       for k=1:7, p=1:n
   174048         dtdq0[i,count[i],k,p] = dtdq[k,p]
        -       end
        -     end
   168021     gsave[i] = gi
        -   end
        -   # Save the current state as prior state:
    24003   xprior = copy(x)
    24003   vprior = copy(v)
    24003   jac_prior = copy(jac_step)
        -   # Increment time by the time step:
    24003   t += h
        -   # Increment counter by one:
    24003   istep +=1
        - end
        3 return 
        - end
        - 
        - function ttv!(n::Int64,t0::Float64,h::Float64,tmax::Float64,elements::Array{Float64,2},tt::Array{Float64,2},count::Array{Int64,1},dlnq::Float64,iq::Int64,jq::Int64)
        - #fcons = open("fcons.txt","w");
        3 m=zeros(Float64,n)
        3 x=zeros(Float64,NDIM,n)
        3 v=zeros(Float64,NDIM,n)
        - # Fill the transit-timing array with zeros:
        3 fill!(tt,0.0)
        - # Counter for transits of each planet:
        3 fill!(count,0)
        3 for i=1:n
       24   m[i] = elements[i,1]
        - end
        - # Allow for perturbations to initial conditions: jq labels body; iq labels phase-space element (or mass)
        - # iq labels phase-space element (1-3: x; 4-6: v; 7: m)
        3 dq = 0.0
        3 if iq == 7 && dlnq != 0.0
        0   dq = m[jq]*dlnq
        0   m[jq] += dq
        - end
        - # Initialize the N-body problem using nested hierarchy of Keplerians:
        3 x,v = init_nbody(elements,t0,n)
        - # Perturb the initial condition by an amount dlnq (if it is non-zero):
        3 if dlnq != 0.0 && iq > 0 && iq < 7
        0   if iq < 4
        0     if x[iq,jq] != 0
        0       dq = x[iq,jq]*dlnq
        -     else
        0       dq = dlnq
        -     end
        0     x[iq,jq] += dq
        -   else
        -   # Same for v
        0     if v[iq-3,jq] != 0
        0       dq = v[iq-3,jq]*dlnq
        -     else
        0       dq = dlnq
        -     end
        0     v[iq-3,jq] += dq
        -   end
        - end
        3 xprior = copy(x)
        3 vprior = copy(v)
        - # Set the time to the initial time:
        3 t = t0
        - # Set step counter to zero:
        3 istep = 0
        - # Jacobian for each step (7 elements+mass, n_planets, 7 elements+mass, n planets):
        - # Save the g function, which computes the relative sky velocity dotted with relative position
        - # between the planets and star:
        3 gsave = zeros(Float64,n)
        3 gi  = 0.0
        3 dt::Float64 = 0.0
        - # Loop over time steps:
        3 while t < t0+tmax
        -   # Carry out a phi^2 mapping step:
        - #  phi2!(x,v,h,m,n)
    96003   dh17!(x,v,h,m,n)
        -   # Check to see if a transit may have occured.  Sky is x-y plane; line of sight is z.
        -   # Star is body 1; planets are 2-nbody:
    96003   for i=2:n
        -     # Compute the relative sky velocity dotted with position:
   672021     gi = g!(i,1,x,v)
   672021     ri = sqrt(x[1,i]^2+x[2,i]^2+x[3,i]^2)
        -     # See if sign switches, and if planet is in front of star (by a good amount):
   672021     if gi > 0 && gsave[i] < 0 && x[3,i] > 0.25*ri
        -       # A transit has occurred between the time steps.
        -       # Approximate the planet-star motion as a Keplerian, weighting over timestep:
     3108       count[i] += 1
        - #      tt[i,count[i]]=t+findtransit!(i,h,gi,gsave[i],m,xprior,vprior,x,v)
     3108       dt = -gsave[i]*h/(gi-gsave[i])
     3108       xtransit = copy(xprior)
     3108       vtransit = copy(vprior)
     3108       dt = findtransit2!(1,i,h,dt,m,xtransit,vtransit)
     3108       tt[i,count[i]]=t+dt
        - #      tt[i,count[i]]=t+findtransit2!(1,i,h,gi,gsave[i],m,xprior,vprior)
        -     end
   672021     gsave[i] = gi
        -   end
        -   # Save the current state as prior state:
    96003   xprior .=x
    96003   vprior .=v
        -   # Increment time by the time step:
    96003   t += h
        -   # Increment counter by one:
    96003   istep +=1
        - end
        3 return dq
        - end
        - 
        - # Advances the center of mass of a binary
        - function centerm!(m::Array{Float64,1},mijinv::Float64,x::Array{Float64,2},v::Array{Float64,2},vcm::Array{Float64,1},delx::Array{Float64,1},delv::Array{Float64,1},i::Int64,j::Int64,h::Float64)
  7582232 for k=1:NDIM
 22746696   x[k,i] +=  m[j]*mijinv*delx[k] + h*vcm[k]
 22746696   x[k,j] += -m[i]*mijinv*delx[k] + h*vcm[k]
 22746696   v[k,i] +=  m[j]*mijinv*delv[k]
 22746696   v[k,j] += -m[i]*mijinv*delv[k]
        - end
  7582232 return
        - end
        - 
        - 
        - # Drifts bodies i & j
        - function driftij!(x::Array{Float64,2},v::Array{Float64,2},i::Int64,j::Int64,h::Float64)
  6064016 for k=1:NDIM
 18192048   x[k,i] += h*v[k,i]
 18192048   x[k,j] += h*v[k,j]
        - end
  6064016 return
        - end
        - 
        - # Drifts bodies i & j
        - function driftij!(x::Array{Float64,2},v::Array{Float64,2},i::Int64,j::Int64,h::Float64,jac_step::Array{Float64,2},nbody::Int64)
  1518216 indi = (i-1)*7
  1518216 indj = (j-1)*7
  1518216 for k=1:NDIM
  4554648   x[k,i] += h*v[k,i]
  4554648   x[k,j] += h*v[k,j]
        -   # Now for Jacobian:
  4554648   for m=1:7*nbody
255060288     jac_step[indi+k,m] += h*jac_step[indi+3+k,m]
255060288     jac_step[indj+k,m] += h*jac_step[indj+3+k,m]
        -   end    
        - end
  1518216 return
        - end
        - 
        - # Carries out a Kepler step for bodies i & j
        - function keplerij!(m::Array{Float64,1},x::Array{Float64,2},v::Array{Float64,2},i::Int64,j::Int64,h::Float64)
        - # The state vector has: 1 time; 2-4 position; 5-7 velocity; 8 r0; 9 dr0dt; 10 beta; 11 s; 12 ds
        - # Initial state:
  6064016 state0 = zeros(Float64,12)
        - # Final state (after a step):
  6064016 state = zeros(Float64,12)
  6064016 delx = zeros(Float64,NDIM)
  6064016 delv = zeros(Float64,NDIM)
        - #println("Masses: ",i," ",j)
  6064016 for k=1:NDIM
 18192048   state0[1+k     ] = x[k,i] - x[k,j]
 18192048   state0[1+k+NDIM] = v[k,i] - v[k,j]
        - end
  6064016 gm = GNEWT*(m[i]+m[j])
  6064016 if gm == 0
        0   for k=1:NDIM
        0     x[k,i] += h*v[k,i]
        0     x[k,j] += h*v[k,j]
        -   end
        - else
        -   # predicted value of s
  6064016   state0[11]=0.0
  6064016   kepler_step!(gm, h, state0, state)
  6064016   for k=1:NDIM
 18192048     delx[k] = state[1+k] - state0[1+k]
 18192048     delv[k] = state[1+NDIM+k] - state0[1+NDIM+k]
        -   end
        - # Advance center of mass:
        - # Compute COM coords:
  6064016   mijinv =1.0/(m[i] + m[j])
  6064016   vcm = zeros(Float64,NDIM)
  6064016   for k=1:NDIM
 18192048     vcm[k] = (m[i]*v[k,i] + m[j]*v[k,j])*mijinv
        -   end
  6064016   centerm!(m,mijinv,x,v,vcm,delx,delv,i,j,h)
        - end
  6064016 return
        - end
        - 
        - # Carries out a Kepler step for bodies i & j
        - function keplerij!(m::Array{Float64,1},x::Array{Float64,2},v::Array{Float64,2},i::Int64,j::Int64,h::Float64,jac_ij::Array{Float64,2})
        - # The state vector has: 1 time; 2-4 position; 5-7 velocity; 8 r0; 9 dr0dt; 10 beta; 11 s; 12 ds
        - # Initial state:
  1518216 state0 = zeros(Float64,12)
        - # Final state (after a step):
  1518216 state = zeros(Float64,12)
  1518216 delx = zeros(Float64,NDIM)
  1518216 delv = zeros(Float64,NDIM)
        - # jac_ij should be the Jacobian for going from (x_{0,i},v_{0,i},m_i) &  (x_{0,j},v_{0,j},m_j)
        - # to  (x_i,v_i,m_i) &  (x_j,v_j,m_j), a 14x14 matrix for the 3-dimensional case. 
        - # Fill with zeros for now:
  1518216 fill!(jac_ij,0.0)
  1518216 for k=1:NDIM
  4554648   state0[1+k     ] = x[k,i] - x[k,j]
  4554648   state0[1+k+NDIM] = v[k,i] - v[k,j]
        - end
  1518216 gm = GNEWT*(m[i]+m[j])
        - # The following jacobian is just computed for the Keplerian coordinates (i.e. doesn't include
        - # center-of-mass motion, or scale to motion of bodies about their common center of mass):
  1518216 jac_kepler = zeros(Float64,7,7)
  1518216 kepler_step!(gm, h, state0, state, jac_kepler)
  1518216 for k=1:NDIM
  4554648   delx[k] = state[1+k] - state0[1+k]
  4554648   delv[k] = state[1+NDIM+k] - state0[1+NDIM+k]
        - end
        - # Compute COM coords:
  1518216 mijinv =1.0/(m[i] + m[j])
  1518216 xcm = zeros(Float64,NDIM)
  1518216 vcm = zeros(Float64,NDIM)
  1518216 mi = m[i]*mijinv # Normalize the masses
  1518216 mj = m[j]*mijinv
        - #println("Masses: ",i," ",j)
  1518216 for k=1:NDIM
  4554648   xcm[k] = mi*x[k,i] + mj*x[k,j]
  4554648   vcm[k] = mi*v[k,i] + mj*v[k,j]
        - end
        - # Compute the Jacobian:
  1518216 jac_ij[ 7, 7] = 1.0  # the masses don't change with time!
  1518216 jac_ij[14,14] = 1.0
  1518216 for k=1:NDIM
  4554648    jac_ij[   k,   k] +=   mi
  4554648    jac_ij[   k, 3+k] += h*mi
  4554648    jac_ij[   k, 7+k] +=   mj
  4554648    jac_ij[   k,10+k] += h*mj
  4554648    jac_ij[ 3+k, 3+k] +=   mi
  4554648    jac_ij[ 3+k,10+k] +=   mj
  4554648    jac_ij[ 7+k,   k] +=   mi
  4554648    jac_ij[ 7+k, 3+k] += h*mi
  4554648    jac_ij[ 7+k, 7+k] +=   mj
  4554648    jac_ij[ 7+k,10+k] += h*mj
  4554648    jac_ij[10+k, 3+k] +=   mi
  4554648    jac_ij[10+k,10+k] +=   mj
  4554648    for l=1:NDIM
        - # Compute derivatives of \delta x_i with respect to initial conditions:
 13663944      jac_ij[   k,   l] += mj*jac_kepler[  k,  l]
 13663944      jac_ij[   k, 3+l] += mj*jac_kepler[  k,3+l]
 13663944      jac_ij[   k, 7+l] -= mj*jac_kepler[  k,  l]
 13663944      jac_ij[   k,10+l] -= mj*jac_kepler[  k,3+l]
        - # Compute derivatives of \delta v_i with respect to initial conditions:
 13663944      jac_ij[ 3+k,   l] += mj*jac_kepler[3+k,  l]
 13663944      jac_ij[ 3+k, 3+l] += mj*jac_kepler[3+k,3+l]
 13663944      jac_ij[ 3+k, 7+l] -= mj*jac_kepler[3+k,  l]
 13663944      jac_ij[ 3+k,10+l] -= mj*jac_kepler[3+k,3+l]
        - # Compute derivatives of \delta x_j with respect to initial conditions:
 13663944      jac_ij[ 7+k,   l] -= mi*jac_kepler[  k,  l]
 13663944      jac_ij[ 7+k, 3+l] -= mi*jac_kepler[  k,3+l]
 13663944      jac_ij[ 7+k, 7+l] += mi*jac_kepler[  k,  l]
 13663944      jac_ij[ 7+k,10+l] += mi*jac_kepler[  k,3+l]
        - # Compute derivatives of \delta v_j with respect to initial conditions:
 13663944      jac_ij[10+k,   l] -= mi*jac_kepler[3+k,  l]
 13663944      jac_ij[10+k, 3+l] -= mi*jac_kepler[3+k,3+l]
 13663944      jac_ij[10+k, 7+l] += mi*jac_kepler[3+k,  l]
 13663944      jac_ij[10+k,10+l] += mi*jac_kepler[3+k,3+l]
        -    end
        - # Compute derivatives of \delta x_i with respect to the masses:
  4554648    jac_ij[   k, 7] += (x[k,i]+h*v[k,i]-xcm[k]-h*vcm[k]-mj*state[1+k])*mijinv + GNEWT*mj*jac_kepler[  k,7]
  4554648    jac_ij[   k,14] += (x[k,j]+h*v[k,j]-xcm[k]-h*vcm[k]+mi*state[1+k])*mijinv + GNEWT*mj*jac_kepler[  k,7]
        - # Compute derivatives of \delta v_i with respect to the masses:
  4554648    jac_ij[ 3+k, 7] += (v[k,i]-vcm[k]-mj*state[4+k])*mijinv + GNEWT*mj*jac_kepler[3+k,7]
  4554648    jac_ij[ 3+k,14] += (v[k,j]-vcm[k]+mi*state[4+k])*mijinv + GNEWT*mj*jac_kepler[3+k,7]
        - # Compute derivatives of \delta x_j with respect to the masses:
  4554648    jac_ij[ 7+k, 7] += (x[k,i]+h*v[k,i]-xcm[k]-h*vcm[k]-mj*state[1+k])*mijinv - GNEWT*mi*jac_kepler[  k,7]
  4554648    jac_ij[ 7+k,14] += (x[k,j]+h*v[k,j]-xcm[k]-h*vcm[k]+mi*state[1+k])*mijinv - GNEWT*mi*jac_kepler[  k,7]
        - # Compute derivatives of \delta v_j with respect to the masses:
  4554648    jac_ij[10+k, 7] += (v[k,i]-vcm[k]-mj*state[4+k])*mijinv - GNEWT*mi*jac_kepler[3+k,7]
  4554648    jac_ij[10+k,14] += (v[k,j]-vcm[k]+mi*state[4+k])*mijinv - GNEWT*mi*jac_kepler[3+k,7]
        - end
        - # Advance center of mass & individual Keplerian motions:
  1518216 centerm!(m,mijinv,x,v,vcm,delx,delv,i,j,h)
  1518216 return
        - end
        - 
        - # Drifts all particles:
        - function drift!(x::Array{Float64,2},v::Array{Float64,2},h::Float64,n::Int64)
   216572 for i=1:n, j=1:NDIM
  5197728   x[j,i] += h*v[j,i]
        - end
   216572 return
        - end
        - 
        - # Drifts all particles:
        - function drift!(x::Array{Float64,2},v::Array{Float64,2},h::Float64,n::Int64,jac_step::Array{Float64,2})
    54222 indi = 0
    54222 for i=1:n
   433776   indi = (i-1)*7
   433776   for j=1:NDIM
  1301328     x[j,i] += h*v[j,i]
        -     # Now for Jacobian:
  1301328     for k=1:7*n
 72874368       jac_step[indi+j,k] += h*jac_step[indi+3+j,k]
        -     end    
        -   end
        - end
    54222 return
        - end
        - 
        - function phisalpha!(x::Array{Float64,2},v::Array{Float64,2},h::Float64,m::Array{Float64,1},alpha::Float64,n::Int64)
        - # Computes the 4th-order correction:
        - #function [v] = phisalpha(x,v,h,m,alpha)
        - #n = size(m,2);
   108286 a = zeros(Float64,3,n)
   108286 rij = zeros(Float64,3)
   108286 aij = zeros(Float64,3)
   108286 coeff = alpha*h^3/96*2*GNEWT
   649716 fac = 0.0; fac1 = 0.0; fac2 = 0.0; r1 = 0.0; r2 = 0.0; r3 = 0.0
   108286 for i=1:n
   866288   for j = i+1:n
  3032008     for k=1:3
  9096024       rij[k] = x[k,i] - x[k,j]
        -     end
  3032008     r2 = rij[1]*rij[1]+rij[2]*rij[2]+rij[3]*rij[3]
  3032008     r3 = r2*sqrt(r2)
  3032008     for k=1:3
  9096024       fac = GNEWT*rij[k]/r3
  9096024       a[k,i] -= m[j]*fac
  9096024       a[k,j] += m[i]*fac
        -     end
        -   end
        - end
        - # Next, compute \tilde g_i acceleration vector (this is rewritten
        - # slightly to avoid reference to \tilde a_i):
   108286 for i=1:n
   866288   for j=i+1:n
  3032008     for k=1:3
  9096024       aij[k] = a[k,i] - a[k,j]
        - #      aij[k] = 0.0
  9096024       rij[k] = x[k,i] - x[k,j]
        -     end
  3032008     r2 = rij[1]*rij[1]+rij[2]*rij[2]+rij[3]*rij[3]
  3032008     r1 = sqrt(r2)
  3032008     ardot = aij[1]*rij[1]+aij[2]*rij[2]+aij[3]*rij[3]
  3032008     fac1 = coeff/r1^5
  3032008     fac2 = (2*GNEWT*(m[i]+m[j])/r1 + 3*ardot) 
  3032008     for k=1:3
        - #      fac = coeff/r1^5*(rij[k]*(2*GNEWT*(m[i]+m[j])/r1 + 3*ardot) - r2*aij[k])
  9096024       fac = fac1*(rij[k]*fac2- r2*aij[k])
  9096024       v[k,i] += m[j]*fac
  9096024       v[k,j] -= m[i]*fac
        -     end
        -   end
        - end
   108286 return
        - end
        - 
        - function phisalpha!(x::Array{Float64,2},v::Array{Float64,2},h::Float64,m::Array{Float64,1},alpha::Float64,n::Int64,jac_step::Array{Float64,2})
        - # Computes the 4th-order correction:
        - #function [v] = phisalpha(x,v,h,m,alpha)
        - #n = size(m,2);
    27111 a = zeros(Float64,3,n)
    27111 dadq = zeros(Float64,3,n,4,n)  # There is no velocity dependence
    27111 dotdadq = zeros(Float64,4,n)  # There is no velocity dependence
    27111 rij = zeros(Float64,3)
    27111 aij = zeros(Float64,3)
    27111 coeff = alpha*h^3/96*2*GNEWT
   189777 fac = 0.0; fac1 = 0.0; fac2 = 0.0; fac3 = 0.0; r1 = 0.0; r2 = 0.0; r3 = 0.0
    27111 for i=1:n-1
   189777   for j = i+1:n
   759108     for k=1:3
  2277324       rij[k] = x[k,i] - x[k,j]
        -     end
   759108     r2 = rij[1]*rij[1]+rij[2]*rij[2]+rij[3]*rij[3]
   759108     r3 = r2*sqrt(r2)
   759108     for k=1:3
  2277324       fac = GNEWT*rij[k]/r3
  2277324       a[k,i] -= m[j]*fac
  2277324       a[k,j] += m[i]*fac
        -       # Mass derivative of acceleration vector (10/6/17 notes):
        -       # Since there is no velocity dependence, this is fourth parameter.
        -       # Acceleration of ith particle depends on mass of jth particle:
  2277324       dadq[k,i,4,j] -= fac
  2277324       dadq[k,j,4,i] += fac
        -       # x derivative of acceleration vector:
  2277324       fac *= 3.0/r2
        -       # Dot product x_ij.\delta x_ij means we need to sum over components:
  2277324       for p=1:3
  6831972         dadq[k,i,p,i] += fac*m[j]*rij[p]
  6831972         dadq[k,i,p,j] -= fac*m[j]*rij[p]
  6831972         dadq[k,j,p,j] += fac*m[i]*rij[p]
  6831972         dadq[k,j,p,i] -= fac*m[i]*rij[p]
        -       end
        -       # Final term has no dot product, so just diagonal:
  2277324       fac = GNEWT/r3
  2277324       dadq[k,i,k,i] -= fac*m[j]
  2277324       dadq[k,i,k,j] += fac*m[j]
  2277324       dadq[k,j,k,j] -= fac*m[i]
  2277324       dadq[k,j,k,i] += fac*m[i]
        -     end
        -   end
        - end
        - # Delete this when finished debugging:
        - #fill!(dadq,0.0)
        - # Next, compute \tilde g_i acceleration vector (this is rewritten
        - # slightly to avoid reference to \tilde a_i):
    27111 fill!(jac_step,0.0)
        - # Note that jac_step[(i-1)*7+k,(j-1)*7+p] is the derivative of the kth coordinate
        - # of planet i with respect to the pth coordinate of planet j.
    27111 for i=1:n-1
   189777   for j=i+1:n
   759108     for k=1:3
  2277324       aij[k] = a[k,i] - a[k,j]
        - #      aij[k] = 0.0
  2277324       rij[k] = x[k,i] - x[k,j]
        -     end
        -     # Compute dot product of r_ij with \delta a_ij:
   759108     fill!(dotdadq,0.0)
   759108     for d=1:n, p=1:4, k=1:3
 72874368       dotdadq[p,d] += rij[k]*(dadq[k,i,p,d]-dadq[k,j,p,d])
        -     end
   759108     r2 = rij[1]*rij[1]+rij[2]*rij[2]+rij[3]*rij[3]
   759108     r1 = sqrt(r2)
   759108     ardot = aij[1]*rij[1]+aij[2]*rij[2]+aij[3]*rij[3]
   759108     fac1 = coeff/r1^5
   759108     fac2 = (2*GNEWT*(m[i]+m[j])/r1 + 3*ardot) 
   759108     for k=1:3
        - #      fac = coeff/r1^5*(rij[k]*(2*GNEWT*(m[i]+m[j])/r1 + 3*ardot) - r2*aij[k])
  2277324       fac = fac1*(rij[k]*fac2- r2*aij[k])
  2277324       v[k,i] += m[j]*fac
  2277324       v[k,j] -= m[i]*fac
        -       # Mass derivative (first part is easy):
  2277324       jac_step[(i-1)*7+3+k,(j-1)*7+7] += fac
  2277324       jac_step[(j-1)*7+3+k,(i-1)*7+7] -= fac
        -       # Position derivatives:
  2277324       fac *= 5.0/r2
  2277324       for p=1:3
  6831972         jac_step[(i-1)*7+3+k,(i-1)*7+p] -= fac*m[j]*rij[p]
  6831972         jac_step[(i-1)*7+3+k,(j-1)*7+p] += fac*m[j]*rij[p]
  6831972         jac_step[(j-1)*7+3+k,(j-1)*7+p] -= fac*m[i]*rij[p]
  6831972         jac_step[(j-1)*7+3+k,(i-1)*7+p] += fac*m[i]*rij[p]
        -       end
        -       # Second mass derivative:
  2277324       fac = 2*GNEWT*fac1*rij[k]/r1
  2277324       jac_step[(i-1)*7+3+k,(i-1)*7+7] += fac*m[j]
  2277324       jac_step[(i-1)*7+3+k,(j-1)*7+7] += fac*m[j]
  2277324       jac_step[(j-1)*7+3+k,(j-1)*7+7] -= fac*m[i]
  2277324       jac_step[(j-1)*7+3+k,(i-1)*7+7] -= fac*m[i]
        -       #  (There's also a mass term in dadq [x]. See below.)
        -       # Diagonal position terms:
  2277324       fac = fac1*fac2
  2277324       jac_step[(i-1)*7+3+k,(i-1)*7+k] += fac*m[j]
  2277324       jac_step[(i-1)*7+3+k,(j-1)*7+k] -= fac*m[j]
  2277324       jac_step[(j-1)*7+3+k,(j-1)*7+k] += fac*m[i]
  2277324       jac_step[(j-1)*7+3+k,(i-1)*7+k] -= fac*m[i]
        -       # Dot product \delta rij terms:
  2277324       fac = -2*fac1*(rij[k]*GNEWT*(m[i]+m[j])/(r2*r1)+aij[k])
  2277324       for p=1:3
  6831972         fac3 = fac*rij[p] + fac1*3.0*rij[k]*aij[p]
  6831972         jac_step[(i-1)*7+3+k,(i-1)*7+p] += m[j]*fac3
  6831972         jac_step[(i-1)*7+3+k,(j-1)*7+p] -= m[j]*fac3
  6831972         jac_step[(j-1)*7+3+k,(j-1)*7+p] += m[i]*fac3
  6831972         jac_step[(j-1)*7+3+k,(i-1)*7+p] -= m[i]*fac3
        -       end
        -       # Diagonal acceleration terms:
  2277324       fac = -fac1*r2
        -       # Duoh.  For dadq, have to loop over all other parameters!
  2277324       for d=1:n
 18218592         for p=1:3
 54655776           jac_step[(i-1)*7+3+k,(d-1)*7+p] += fac*m[j]*(dadq[k,i,p,d]-dadq[k,j,p,d])
 54655776           jac_step[(j-1)*7+3+k,(d-1)*7+p] -= fac*m[i]*(dadq[k,i,p,d]-dadq[k,j,p,d])
        -         end
        -         # Don't forget mass-dependent term:
 18218592         jac_step[(i-1)*7+3+k,(d-1)*7+7] += fac*m[j]*(dadq[k,i,4,d]-dadq[k,j,4,d])
 18218592         jac_step[(j-1)*7+3+k,(d-1)*7+7] -= fac*m[i]*(dadq[k,i,4,d]-dadq[k,j,4,d])
        -       end
        -       # Now, for the final term:  (\delta a_ij . r_ij ) r_ij
  2277324       fac = 3.*fac1*rij[k]
  2277324       for d=1:n
 18218592         for p=1:3
 54655776           jac_step[(i-1)*7+3+k,(d-1)*7+p] += fac*m[j]*dotdadq[p,d]
 54655776           jac_step[(j-1)*7+3+k,(d-1)*7+p] -= fac*m[i]*dotdadq[p,d]
        -         end
 18218592         jac_step[(i-1)*7+3+k,(d-1)*7+7] += fac*m[j]*dotdadq[4,d]
 18218592         jac_step[(j-1)*7+3+k,(d-1)*7+7] -= fac*m[i]*dotdadq[4,d]
        -       end
        -     end
        -   end
        - end
    27111 for i=1:n
   216888   for k=1:3
        -   # Position remains unchanged, so Jacobian of position should be identity matrix:
   650664     jac_step[(i-1)*7+  k,(i-1)*7+  k] += 1.0
        -   # Jacobian of velocity has linear dependence on initial velocity
   650664     jac_step[(i-1)*7+3+k,(i-1)*7+3+k] += 1.0
        -   end
        -   # Mass remains unchanged:
   216888   jac_step[(i-1)*7+7,(i-1)*7+7] += 1.0
        - end
    27111 return
        - end
        - 
        - # Carries out the DH17 mapping
        - function dh17!(x::Array{Float64,2},v::Array{Float64,2},h::Float64,m::Array{Float64,1},n::Int64)
   108286 alpha = alpha0
   108286 h2 = 0.5*h
        - # alpha = 0. is similar in precision to alpha=0.25
   108286 if alpha != 0.0
        0   phisalpha!(x,v,h,m,alpha,n)
        - end
   108286 drift!(x,v,h2,n)
   108286 for i=1:n-1
   758002   for j=i+1:n
  3032008     driftij!(x,v,i,j,-h2)
  3032008     keplerij!(m,x,v,i,j,h2)
        -   end
        - end
   108286 if alpha != 1.0
   108286   phisalpha!(x,v,h,m,2.*(1.-alpha),n)
        - end
   108286 for i=n-1:-1:1
   758002   for j=n:-1:i+1
  3032008     keplerij!(m,x,v,i,j,h2)
  3032008     driftij!(x,v,i,j,-h2)
        -   end
        - end
   108286 drift!(x,v,h2,n)
   108286 if alpha != 0.0
        0   phisalpha!(x,v,h,m,alpha,n)
        - end
   108286 return
        - end
        - 
        - # Used in computing the transit time:
        - function g!(i::Int64,j::Int64,x::Array{Float64,2},v::Array{Float64,2})
        - # See equation 8-10 Fabrycky (2008) in Seager Exoplanets book
   855433 g = (x[1,j]-x[1,i])*(v[1,j]-v[1,i])+(x[2,j]-x[2,i])*(v[2,j]-v[2,i])
   855433 return g
        - end
        - 
        - # Carries out the DH17 mapping & computes the jacobian:
        - function dh17!(x::Array{Float64,2},v::Array{Float64,2},h::Float64,m::Array{Float64,1},n::Int64,jac_step::Array{Float64,2})
    27111 h2 = 0.5*h
    27111 alpha = alpha0
    27111 jac_phi = zeros(Float64,7*n,7*n)
    27111 jac_tmp = zeros(Float64,7*n,7*n)
    27111 jac_step_ij = zeros(Float64,14,7*n)
        - # alpha = 0. is similar in precision to alpha=0.25
    27111 if alpha != 0.0
        0   phisalpha!(x,v,h,m,alpha,n,jac_phi)
        0   jac_step .= jac_phi*jac_step # < 1%
        - end
    27111 drift!(x,v,h2,n,jac_step)
    27111 jac_ij = zeros(Float64,14,14)
    27111 for i=1:n-1
   189777   for j=i+1:n
   759108     driftij!(x,v,i,j,-h2,jac_step,n)
   759108     keplerij!(m,x,v,i,j,h2,jac_ij) # 21%
   759108     for k1=1:7, k2=1:7*n
297570336       jac_step_ij[  k1,k2]=jac_step[(i-1)*7+k1,k2]
297570336       jac_step_ij[7+k1,k2]=jac_step[(j-1)*7+k1,k2]
        -     end
   759108     jac_step_ij .= *(jac_ij,jac_step_ij)
   759108     for k1=1:7, k2=1:7*n
297570336       jac_step[(i-1)*7+k1,k2]=jac_step_ij[  k1,k2]
297570336       jac_step[(j-1)*7+k1,k2]=jac_step_ij[7+k1,k2]
        -     end
        -   end
        - end
    27111 if alpha != 1.0
    27111   phisalpha!(x,v,h,m,2.*(1.-alpha),n,jac_phi) # 10%
    27111   jac_step .= jac_phi*jac_step # < 1%
        - end
    27111 indi=0; indj=0
   189777 for i=n-1:-1:1
   759108   indi=(i-1)*7
   759108   for j=n:-1:i+1
297570336     indj=(j-1)*7
297570336     keplerij!(m,x,v,i,j,h2,jac_ij) # 23%
        -     for k2=1:7*n, k1=1:7
   759108       jac_step_ij[  k1,k2]=jac_step[indi+k1,k2]
   759108       jac_step_ij[7+k1,k2]=jac_step[indj+k1,k2]
297570336     end
297570336     jac_step_ij .= *(jac_ij,jac_step_ij)
        -     for k2=1:7*n, k1=1:7
   759108       jac_step[indi+k1,k2]=jac_step_ij[  k1,k2]
        -       jac_step[indj+k1,k2]=jac_step_ij[7+k1,k2]
        -     end
    27111     driftij!(x,v,i,j,-h2,jac_step,n) 
    27111   end
        0 end
        0 drift!(x,v,h2,n,jac_step)
        - if alpha != 0.0
    27111   phisalpha!(x,v,h,m,alpha,n,jac_phi)
        -   jac_step .= jac_phi*jac_step # < 1%
        - end
        - return
        - end
        - 
        - function findtransit!(i,h,g1,g2,m,x1,v1,x2,v2)
        - # Computes the transit time, approximating the motion
        - # as a Keplerian forward & backward in time, weighted by location in the timestep.
        - # Initial guess using linear interpolation:
        - tt = -g1*h/(g2-g1)
        - dt = 1.0
        - 
        - # Setup state vectors for kepler_step:
        - s10 = zeros(Float64,12)
        - s20 = zeros(Float64,12)
        - # Final state (after a step):
        - s1 = zeros(Float64,12)
        - s2 = zeros(Float64,12)
        - s = zeros(Float64,12)
        - for k=1:NDIM
        -   s10[1+k     ] = x1[k,i] - x1[k,1]
        -   s10[1+k+NDIM] = v1[k,i] - v1[k,1]
        -   s20[1+k     ] = x2[k,i] - x2[k,1]
        -   s20[1+k+NDIM] = v2[k,i] - v2[k,1]
        - end
        - gm = GNEWT*(m[i]+m[1])
        - iter = 0
        - accel1= 0.
        - accel2= 0.
        - accel = zeros(Float64,3)
        - while abs(dt) > 1e-8 && iter < 20
        -   # Advance planet state at start of step to estimated transit time:
        -   kepler_step!(gm,    tt, s10, s1)
        -   # Reverse planet state at end of step to estimated transit time:
        -   kepler_step!(gm, -h+tt, s20, s2)
        -   # Weight:
        -   w = tt/h
        -   # Compute weighting of states:
        -   for j=2:7
        -     s[j] = (1.0-w)*s1[j]+w*s2[j]
        -   end
        -   # Compute time offset:
        -   g = s[2]*s[5]+s[3]*s[6]
        -   # Compute gravitational acceleration
        -   r1_3 = norm(s1[2:4])^3
        -   r2_3 = norm(s2[2:4])^3
        -   for k=1:3
        -     accel1 = -gm*s1[k+1]/r1_3
        -     accel2 = -gm*s2[k+1]/r2_3
        -     accel[k] = accel1*(1.0-w)+accel2*w
        -   end
        -   # Compute derivative of g with respect to time:
        -   gdot = s[5]^2+s[6]^2+s[2]*accel[1]+s[3]*accel[2]
        -   # Include time derivatives of interpolation (10/4/17 notes):
        -   gdot += ((s2[2]-s1[2])*s[5] + (s2[5]-s1[5])*s[2] +(s2[3]-s1[3])*s[6]+(s2[6]-s1[6])*s[3])/h
        -   # Refine estimate of transit time with Newton's method:
        -   dt = -g/gdot
        -   # Add refinement to estimated time:
        -   tt += dt
        -   iter +=1
        - end
        - # Note: this is the time elapsed *after* the beginning of the timestep:
        - return tt
        - end
        - 
        - function findtransit!(i,h,g1,g2,m,x1,v1,x2,v2,dtdqn)
        - # Computes the transit time, approximating the motion
        - # as a Keplerian forward & backward in time, weighted by location in the timestep.
        - # Initial guess using linear interpolation:
        - tt = -g1*h/(g2-g1)
        - dt = 1.0
        - 
        - # Vector for computing derivative with respect to the initial and final elements
        - # of the planet & star -  2 planets with 7 elements/masses at two times (initial & final):
        - dtdqn = zeros(7,2,2)
        - 
        - # Setup state vectors for kepler_step:
        - s10 = zeros(Float64,12)
        - s20 = zeros(Float64,12)
        - # Final state (after a step):
        - s1 = zeros(Float64,12)
        - s2 = zeros(Float64,12)
        - s = zeros(Float64,12)
        - for k=1:NDIM
        -   s10[1+k     ] = x1[k,i] - x1[k,1]
        -   s10[1+k+NDIM] = v1[k,i] - v1[k,1]
        -   s20[1+k     ] = x2[k,i] - x2[k,1]
        -   s20[1+k+NDIM] = v2[k,i] - v2[k,1]
        - end
        - gm = GNEWT*(m[i]+m[1])
        - iter = 0
        - accel1= 0.
        - accel2= 0.
        - accel = zeros(Float64,3)
        - while abs(dt) > 1e-8 && iter < 20
        -   # Advance planet state at start of step to estimated transit time:
        -   kepler_step!(gm,    tt, s10, s1)
        -   # Reverse planet state at end of step to estimated transit time:
        -   kepler_step!(gm, -h+tt, s20, s2)
        -   # Weight:
        -   w = tt/h
        -   # Compute weighting of states:
        -   for j=2:7
        -     s[j] = (1.0-w)*s1[j]+w*s2[j]
        -   end
        -   # Compute time offset:
        -   g = s[2]*s[5]+s[3]*s[6]
        -   # Compute gravitational acceleration
        -   r1_3 = norm(s1[2:4])^3
        -   r2_3 = norm(s2[2:4])^3
        -   for k=1:3
        -     accel1 = -gm*s1[k+1]/r1_3
        -     accel2 = -gm*s2[k+1]/r2_3
        -     accel[k] = accel1*(1.0-w)+accel2*w
        -   end
        -   # Compute derivative of g with respect to time:
        -   gdot = s[5]^2+s[6]^2+s[2]*accel[1]+s[3]*accel[2]
        -   # Include time derivatives of interpolation (10/4/17 notes):
        -   gdot += ((s2[2]-s1[2])*s[5] + (s2[5]-s1[5])*s[2] +(s2[3]-s1[3])*s[6]+(s2[6]-s1[6])*s[3])/h
        -   # Refine estimate of transit time with Newton's method:
        -   dt = -g/gdot
        -   # Add refinement to estimated time:
        -   tt += dt
        -   iter +=1
        - end
        - # Now compute derivative of transit time with respect to initial (& final)
        - # positions & masses of the planet/star:
        - 
        - 
        - # Note: this is the time elapsed *after* the beginning of the timestep:
        - return tt
        - end
        - 
     3108 function findtransit2!(i::Int64,j::Int64,h::Float64,tt::Float64,m::Array{Float64,1},x1::Array{Float64,2},v1::Array{Float64,2})
     3108 # Computes the transit time, approximating the motion as a fraction of a DH17 step forward in time.
     3108 # Initial guess using linear interpolation:
     3108 dt = 1.0
     3108 iter = 0
     3108 r3 = 0.0
     3108 gdot = 0.0
     6067 x = copy(x1)
     6067 v = copy(v1)
        - while abs(dt) > 1e-8 && iter < 20
     6067   x = copy(x1)
        -   v = copy(v1)
     6067   # Advance planet state at start of step to estimated transit time:
        -   dh17!(x,v,tt,m,n)
     6067   # Compute time offset:
     6067   gsky = g!(i,j,x,v)
    48536   # Compute gravitational acceleration in sky plane dotted with sky position:
    42469   gdot = 0.0
    42469   for k=1:n
        -     if k != i
    48536       r3 = sqrt((x[1,k]-x[1,i])^2+(x[2,k]-x[2,i])^2 +(x[3,k]-x[3,i])^2)^3
    42469       gdot += GNEWT*m[k]*((x[1,k]-x[1,i])*(x[1,j]-x[1,i])+(x[2,k]-x[2,i])*(x[2,j]-x[2,i]))/r3
    42469     end
        -     if k != j
        -       r3 = sqrt((x[1,k]-x[1,j])^2+(x[2,k]-x[2,j])^2 +(x[3,k]-x[3,j])^2)^3
        -       gdot -= GNEWT*m[k]*((x[1,k]-x[1,j])*(x[1,j]-x[1,i])+(x[2,k]-x[2,j])*(x[2,j]-x[2,i]))/r3
     6067     end
        -   end
     6067   # Compute derivative of g with respect to time:
        -   gdot += (v[1,j]-v[1,i])^2+(v[2,j]-v[2,i])^2
     6067   # Refine estimate of transit time with Newton's method:
     6067   dt = -gsky/gdot
        -   # Add refinement to estimated time:
        -   tt += dt
        -   iter +=1
        - end
     3108 # Compute derivatives:
        - #  dh17!(x,v,tt,m,n,jac_step)
        - # Note: this is the time elapsed *after* the beginning of the timestep:
        - return tt::Float64
        - end
        - 
        - function findtransit2!(i::Int64,j::Int64,h::Float64,tt::Float64,m::Array{Float64,1},x1::Array{Float64,2},v1::Array{Float64,2},jac_step::Array{Float64,2},dtdq::Array{Float64,2})
     3108 # Computes the transit time, approximating the motion as a fraction of a DH17 step forward in time.
     3108 # Also computes the Jacobian of the transit time with respect to the initial parameters, dtdq[7,n].
     3108 # Initial guess using linear interpolation:
     3108 dt = 1.0
     3108 iter = 0
     3108 r3 = 0.0
     3108 gdot = 0.0
     6216 x = copy(x1)
     6216 v = copy(v1)
        - while abs(dt) > 1e-8 && iter < 20
     6216   x = copy(x1)
        -   v = copy(v1)
     6216   # Advance planet state at start of step to estimated transit time:
        -   dh17!(x,v,tt,m,n)
     6216   # Compute time offset:
     6216   gsky = g!(i,j,x,v)
    49728   # Compute gravitational acceleration in sky plane dotted with sky position:
    43512   gdot = 0.0
    43512   for k=1:n
        -     if k != i
    49728       r3 = sqrt((x[1,k]-x[1,i])^2+(x[2,k]-x[2,i])^2 +(x[3,k]-x[3,i])^2)^3
    43512       gdot += GNEWT*m[k]*((x[1,k]-x[1,i])*(x[1,j]-x[1,i])+(x[2,k]-x[2,i])*(x[2,j]-x[2,i]))/r3
    43512     end
        -     if k != j
        -       r3 = sqrt((x[1,k]-x[1,j])^2+(x[2,k]-x[2,j])^2 +(x[3,k]-x[3,j])^2)^3
        -       gdot -= GNEWT*m[k]*((x[1,k]-x[1,j])*(x[1,j]-x[1,i])+(x[2,k]-x[2,j])*(x[2,j]-x[2,i]))/r3
     6216     end
        -   end
     6216   # Compute derivative of g with respect to time:
        -   gdot += (v[1,j]-v[1,i])^2+(v[2,j]-v[2,i])^2
     6216   # Refine estimate of transit time with Newton's method:
     6216   dt = -gsky/gdot
        -   # Add refinement to estimated time:
        -   tt += dt
     3108   iter +=1
     3108 end
        - # Compute time derivatives:
     3108 x = copy(x1)
        - v = copy(v1)
     3108 # Compute dgdt with the updated time step.
        - dh17!(x,v,tt,m,n,jac_step)
     3108 # Compute time offset:
     3108 gsky = g!(i,j,x,v)
    24864 # Compute gravitational acceleration in sky plane dotted with sky position:
    21756 gdot = 0.0
    21756 for k=1:n
        -   if k != i
    24864     r3 = sqrt((x[1,k]-x[1,i])^2+(x[2,k]-x[2,i])^2 +(x[3,k]-x[3,i])^2)^3
    21756     gdot += GNEWT*m[k]*((x[1,k]-x[1,i])*(x[1,j]-x[1,i])+(x[2,k]-x[2,i])*(x[2,j]-x[2,i]))/r3
    21756   end
        -   if k != j
        -     r3 = sqrt((x[1,k]-x[1,j])^2+(x[2,k]-x[2,j])^2 +(x[3,k]-x[3,j])^2)^3
        -     gdot -= GNEWT*m[k]*((x[1,k]-x[1,j])*(x[1,j]-x[1,i])+(x[2,k]-x[2,j])*(x[2,j]-x[2,i]))/r3
     3108   end
        - end
     3108 # Compute derivative of g with respect to time:
     3108 gdot += (v[1,j]-v[1,i])^2+(v[2,j]-v[2,i])^2
    21756 # Set dtdq to zero:
        - fill!(dtdq,0.0)
   174048 for k=1:7
   174048   for p=1:n
   174048     # Compute derivatives:
   174048     indj = (j-1)*7+1
        -     indi = (i-1)*7+1
        -     indp = (p-1)*7
        -     dtdq[k,p] = -((jac_step[indj,indp+k]-jac_step[indi,indp+k])*(v[1,j]-v[1,i])+(jac_step[indj+1,indp+k]-jac_step[indi+1,indp+k])*(v[2,j]-v[2,i])+
        -                   (jac_step[indj+3,indp+k]-jac_step[indi+3,indp+k])*(x[1,j]-x[1,i])+(jac_step[indj+4,indp+k]-jac_step[indi+4,indp+k])*(x[2,j]-x[2,i]))/gdot
     3108   end
        - end
        - # Note: this is the time elapsed *after* the beginning of the timestep:
        - return tt::Float64
        - end
        - 
