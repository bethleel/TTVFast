        - # Wisdom & Hernandez version of Kepler solver, but with quartic
        - # convergence.
        - 
        - function calc_ds_opt(y,yp,ypp,yppp)
        - # Computes quartic Newton's update to equation y=0 using first through 3rd derivatives.
        - # Uses techniques outlined in Murray & Dermott for Kepler solver.
        - # Rearrange to reduce number of divisions:
 12465827 num = y*yp
 12465827 den1 = yp*yp-y*ypp*.5
 12465827 den12 = den1*den1
 12465827 den2 = yp*den12-num*.5*(ypp*den1-third*num*yppp)
 12465827 return -y*den12/den2
        - end
        - 
        - function kep_elliptic!(x0::Array{Float64,1},v0::Array{Float64,1},r0::Float64,dr0dt::Float64,k::Float64,h::Float64,beta0::Float64,s0::Float64,state::Array{Float64,1})
        - # Solves equation (35) from Wisdom & Hernandez for the elliptic case.
        - 
  1454040 r0inv = inv(r0)
  1454040 beta0inv = inv(beta0)
        - # Now, solve for s in elliptical Kepler case:
  1454040 if beta0 > 0.0
        - # Initial guess (if s0 = 0):
  1454040   if s0 == 0.0
  1454040     s = h*r0inv
        -   else
        0     s = copy(s0)
        -   end
  1454040   s0 = copy(s)
  1454040   sqb = sqrt(beta0)
  2908080   y = 0.0; yp = 1.0
  1454040   iter = 0
  1454040   ds = Inf
  1454040   fac1 = k-r0*beta0
  1454040   fac2 = r0*dr0dt
  1454040   while iter == 0 || (abs(ds) > KEPLER_TOL && iter < 10)
  2872647     xx = sqb*s
  2872647     sx = sqb*sin(xx)
  2872647     cx = cos(xx)
        - # Third derivative:
  2872647     yppp = fac1*cx - fac2*sx
        - # Take derivative:
  2872647     yp = (-yppp+ k)*beta0inv
        - # Second derivative:
  2872647     ypp = fac1*beta0inv*sx + fac2*cx
  2872647     y  = (-ypp + fac2 +k*s)*beta0inv - h  # eqn 35
        - # Now, compute fourth-order estimate:
  2872647     ds = calc_ds_opt(y,yp,ypp,yppp)
  2872647     s += ds
  2872647     iter +=1
        - #    println(iter," ds: ",ds)
        -   end
        - #  if iter > 1
        - #    println(iter," ",s," ",s/s0-1," ds: ",ds)
        - #  end
        - # Since we updated s, need to recompute:
  4362120   xx = 0.5*sqb*s; sx = sin(xx) ; cx = cos(xx)
        - # Now, compute final values:
  1454040   g1bs = 2.*sx*cx/sqb
  1454040   g2bs = 2.*sx^2*beta0inv
  1454040   f = 1.0 - k*r0inv*g2bs # eqn (25)
  1454040   g = r0*g1bs + fac2*g2bs # eqn (27)
  1454040   for j=1:3
        - # Position is components 2-4 of state:
  4362120     state[1+j] = x0[j]*f+v0[j]*g
        -   end
  1454040   r = sqrt(state[2]*state[2]+state[3]*state[3]+state[4]*state[4])
  1454040   rinv = inv(r)
  1454040   dfdt = -k*g1bs*rinv*r0inv
  1454040   dgdt = r0*(1.0-beta0*g2bs+dr0dt*g1bs)*rinv
  1454040   for j=1:3
        - # Velocity is components 5-7 of state:
  4362120     state[4+j] = x0[j]*dfdt+v0[j]*dgdt
        -   end
        - else
        0   println("Not elliptic ",beta0," x0 ",x0)
        - end
        - # recompute beta:
  1454040 state[8]= r
  1454040 state[9] = (state[2]*state[5]+state[3]*state[6]+state[4]*state[7])*rinv
        - # beta is element 10 of state:
  1454040 state[10] = 2.0*k*rinv-(state[5]*state[5]+state[6]*state[6]+state[7]*state[7])
        - # s is element 11 of state:
  1454040 state[11] = s
        - # ds is element 12 of state:
  1454040 state[12] = ds
  1454040 return iter
        - end
        - 
        - function kep_elliptic!(x0::Array{Float64,1},v0::Array{Float64,1},r0::Float64,dr0dt::Float64,k::Float64,h::Float64,beta0::Float64,s0::Float64,state::Array{Float64,1},jacobian::Array{Float64,2})
        - # Computes the Jacobian as well
        - # Solves equation (35) from Wisdom & Hernandez for the elliptic case.
        - 
   109347 r0inv = inv(r0)
   109347 beta0inv = inv(beta0)
        - # Now, solve for s in elliptical Kepler case:
   109347 if beta0 > 0.0
        - # Initial guess (if s0 = 0):
   109347   if s0 == 0.0
   109347     s = h*r0inv
        -   else
        0     s = copy(s0)
        -   end
   109347   s0 = copy(s)
   109347   sqb = sqrt(beta0)
   218694   y = 0.0; yp = 1.0
   109347   iter = 0
   109347   ds = Inf
   109347   fac1 = k-r0*beta0
   109347   fac2 = r0*dr0dt
   109347   while iter == 0 || (abs(ds) > KEPLER_TOL && iter < 10)
   218341     xx = sqb*s
   218341     sx = sqb*sin(xx)
   218341     cx = cos(xx)
        - # Third derivative:
   218341     yppp = fac1*cx - fac2*sx
        - # Take derivative:
   218341     yp = (-yppp+ k)*beta0inv
        - # Second derivative:
   218341     ypp = fac1*beta0inv*sx + fac2*cx
   218341     y  = (-ypp + fac2 +k*s)*beta0inv - h  # eqn 35
        - # Now, compute fourth-order estimate:
   218341     ds = calc_ds_opt(y,yp,ypp,yppp)
   218341     s += ds
   218341     iter +=1
        - #    println(iter," ds: ",ds)
        -   end
        - #  if iter > 1
        - #    println(iter," ",s," ",s/s0-1," ds: ",ds)
        - #  end
        - # Since we updated s, need to recompute:
   328041   xx = 0.5*sqb*s; sx = sin(xx) ; cx = cos(xx)
        - # Now, compute final values:
   109347   g1bs = 2.*sx*cx/sqb
   109347   g2bs = 2.*sx^2*beta0inv
   109347   f = 1.0 - k*r0inv*g2bs # eqn (25)
   109347   g = r0*g1bs + fac2*g2bs # eqn (27)
   109347   for j=1:3
        - # Position is components 2-4 of state:
   328041     state[1+j] = x0[j]*f+v0[j]*g
        -   end
   109347   r = sqrt(state[2]*state[2]+state[3]*state[3]+state[4]*state[4])
   109347   rinv = inv(r)
   109347   dfdt = -k*g1bs*rinv*r0inv
   109347   dgdt = r0*(1.0-beta0*g2bs+dr0dt*g1bs)*rinv
   109347   for j=1:3
        - # Velocity is components 5-7 of state:
   328041     state[4+j] = x0[j]*dfdt+v0[j]*dgdt
        -   end
        - # Now, compute the jacobian:
   109347   fill!(jacobian,0.0)
   109347   compute_jacobian!(h,k,x0,v0,beta0,s,f,g,dfdt,dgdt,cx,sx,g1bs,g2bs,r0,dr0dt,r,jacobian)
        - else
        0   println("Not elliptic ",beta0," x0 ",x0)
        - end
        - # recompute beta:
   109347 state[8]= r
   109347 state[9] = (state[2]*state[5]+state[3]*state[6]+state[4]*state[7])*rinv
        - # beta is element 10 of state:
   109347 state[10] = 2.0*k*rinv-(state[5]*state[5]+state[6]*state[6]+state[7]*state[7])
        - # s is element 11 of state:
   109347 state[11] = s
        - # ds is element 12 of state:
   109347 state[12] = ds
        - # Compute the Jacobian.  jacobian[i,j] is derivative of final state variable q[i]
        - # with respect to initial state variable q0[j], where q = {x,v} & q0 = {x0,v0}.
        - 
   109347 return iter
        - end
        - 
        - function kep_hyperbolic!(x0::Array{Float64,1},v0::Array{Float64,1},r0::Float64,dr0dt::Float64,k::Float64,h::Float64,beta0::Float64,s0::Float64,state::Array{Float64,1})
        - # Solves equation (35) from Wisdom & Hernandez for the hyperbolic case.
        - 
  4362120 r0inv = inv(r0)
  4362120 beta0inv = inv(beta0)
        - # Now, solve for s in hyperbolic Kepler case:
  4362120 if beta0 < 0.0
        - # Initial guess (if s0 = 0):
  4362120   if s0 == 0.0
  4362120     s = h*r0inv
        -   else
        0     s = copy(s0)
        -   end
  4362120   s0 = copy(s)
  4362120   sqb = sqrt(-beta0)
  8724240   y = 0.0; yp = 1.0
  4362120   iter = 0
  4362120   ds = Inf
  4362120   fac1 = k-r0*beta0
  4362120   fac2 = r0*dr0dt
  4362120   while iter == 0 || (abs(ds) > KEPLER_TOL && iter < 10)
 26156724     xx = sqb*s; cx = cosh(xx); sx = sqb*(exp(xx)-cx)
        - # Third derivative:
  8718908     yppp = fac1*cx + fac2*sx
        - # Take derivative:
  8718908     yp = (-yppp+ k)*beta0inv
        - # Second derivative:
  8718908     ypp = -fac1*beta0inv*sx  + fac2*cx
  8718908     y  = (-ypp +fac2 +k*s)*beta0inv - h  # eqn 35
        - # Now, compute fourth-order estimate:
  8718908     ds = calc_ds_opt(y,yp,ypp,yppp)
  8718908     s += ds
  8718908     iter +=1
        - #    println(iter," ds: ",ds)
        -   end
        - #  if iter > 1
        - #    #println("iter: ",iter," ds/s: ",ds/s0)
        - #    println(iter," ",s," ",s/s0-1," ds: ",ds)
        - #  end
 13086360   xx = 0.5*sqb*s; cx = cosh(xx); sx = exp(xx)-cx
        - # Now, compute final values:
  4362120   g1bs = 2.0*sx*cx/sqb
  4362120   g2bs = -2.0*sx^2*beta0inv
  4362120   f = 1.0 - k*r0inv*g2bs # eqn (25)
  4362120   g = r0*g1bs + fac2*g2bs # eqn (27)
  4362120   for j=1:3
 13086360     state[1+j] = x0[j]*f+v0[j]*g
        -   end
        -   # r = norm(x)
  4362120   r = sqrt(state[2]*state[2]+state[3]*state[3]+state[4]*state[4])
  4362120   rinv = inv(r)
  4362120   dfdt = -k*g1bs*rinv*r0inv
  4362120   dgdt = r0*(1.0-beta0*g2bs+dr0dt*g1bs)*rinv
  4362120   for j=1:3
        - # Velocity is components 5-7 of state:
 13086360     state[4+j] = x0[j]*dfdt+v0[j]*dgdt
        -   end
        - else
        0   println("Not hyperbolic",beta0," x0 ",x0)
        - end
        - # recompute beta:
  4362120 state[8]= r
  4362120 state[9] = (state[2]*state[5]+state[3]*state[6]+state[4]*state[7])*rinv
        - # beta is element 10 of state:
  4362120 state[10] = 2.0*k*rinv-(state[5]*state[5]+state[6]*state[6]+state[7]*state[7])
        - # s is element 11 of state:
  4362120 state[11] = s
        - # ds is element 12 of state:
  4362120 state[12] = ds
  4362120 return iter
        - end
        - 
        - function kep_hyperbolic!(x0::Array{Float64,1},v0::Array{Float64,1},r0::Float64,dr0dt::Float64,k::Float64,h::Float64,beta0::Float64,s0::Float64,state::Array{Float64,1},jacobian::Array{Float64,2})
        - # Solves equation (35) from Wisdom & Hernandez for the hyperbolic case.
        - 
   328039 r0inv = inv(r0)
   328039 beta0inv = inv(beta0)
        - # Now, solve for s in hyperbolic Kepler case:
   328039 if beta0 < 0.0
        - # Initial guess (if s0 = 0):
   328039   if s0 == 0.0
   328039     s = h*r0inv
        -   else
        0     s = copy(s0)
        -   end
   328039   s0 = copy(s)
   328039   sqb = sqrt(-beta0)
   656078   y = 0.0; yp = 1.0
   328039   iter = 0
   328039   ds = Inf
   328039   fac1 = k-r0*beta0
   328039   fac2 = r0*dr0dt
   328039   while iter == 0 || (abs(ds) > KEPLER_TOL && iter < 10)
  1967793     xx = sqb*s; cx = cosh(xx); sx = sqb*(exp(xx)-cx)
        - # Third derivative:
   655931     yppp = fac1*cx + fac2*sx
        - # Take derivative:
   655931     yp = (-yppp+ k)*beta0inv
        - # Second derivative:
   655931     ypp = -fac1*beta0inv*sx  + fac2*cx
   655931     y  = (-ypp +fac2 +k*s)*beta0inv - h  # eqn 35
        - # Now, compute fourth-order estimate:
   655931     ds = calc_ds_opt(y,yp,ypp,yppp)
   655931     s += ds
   655931     iter +=1
        - #    println(iter," ds: ",ds)
        -   end
        - #  if iter > 1
        - #    #println("iter: ",iter," ds/s: ",ds/s0)
        - #    println(iter," ",s," ",s/s0-1," ds: ",ds)
        - #  end
   984117   xx = 0.5*sqb*s; cx = cosh(xx); sx = exp(xx)-cx
        - # Now, compute final values:
   328039   g1bs = 2.0*sx*cx/sqb
   328039   g2bs = -2.0*sx^2*beta0inv
   328039   f = 1.0 - k*r0inv*g2bs # eqn (25)
   328039   g = r0*g1bs + fac2*g2bs # eqn (27)
   328039   for j=1:3
   984117     state[1+j] = x0[j]*f+v0[j]*g
        -   end
        -   # r = norm(x)
   328039   r = sqrt(state[2]*state[2]+state[3]*state[3]+state[4]*state[4])
   328039   rinv = inv(r)
   328039   dfdt = -k*g1bs*rinv*r0inv
   328039   dgdt = r0*(1.0-beta0*g2bs+dr0dt*g1bs)*rinv
   328039   for j=1:3
        - # Velocity is components 5-7 of state:
   984117     state[4+j] = x0[j]*dfdt+v0[j]*dgdt
        -   end
        - # Now, compute the jacobian:
   328039   fill!(jacobian,0.0)
   328039   compute_jacobian!(h,k,x0,v0,beta0,s,f,g,dfdt,dgdt,cx,sx,g1bs,g2bs,r0,dr0dt,r,jacobian)
        - else
        0   println("Not hyperbolic",beta0," x0 ",x0)
        - end
        - # recompute beta:
   328039 state[8]= r
   328039 state[9] = (state[2]*state[5]+state[3]*state[6]+state[4]*state[7])*rinv
        - # beta is element 10 of state:
   328039 state[10] = 2.0*k*rinv-(state[5]*state[5]+state[6]*state[6]+state[7]*state[7])
        - # s is element 11 of state:
   328039 state[11] = s
        - # ds is element 12 of state:
   328039 state[12] = ds
   328039 return iter
        - end
        - 
        - function compute_jacobian!(h::Float64,k::Float64,x0::Array{Float64,1},v0::Array{Float64,1},beta0::Float64,s::Float64,f::Float64,g::Float64,dfdt::Float64,dgdt::Float64,cx::Float64,sx::Float64,g1::Float64,g2::Float64,r0::Float64,dr0dt::Float64,r::Float64,jacobian::Array{Float64,2})
        - # Compute the Jacobian.  jacobian[i,j] is derivative of final state variable q[i]
        - # with respect to initial state variable q0[j], where q = {x,v,k} & q0 = {x0,v0,k}.
        - # Now, compute the Jacobian: (9/18/2017 notes)
        - #g0 = cx^2-sx^2
   437386 g0 = 1.0-beta0*g2
   437386 g3 = (s-g1)/beta0
   437386 dotalpha0 = r0*dr0dt  # unnecessary to divide by r0 for dr0dt & multiply for \dot\alpha_0
   437386 absv0 = sqrt(dot(v0,v0))
   437386 dsdbeta = (2h-r0*(s*g0+g1)+k/beta0*(s*g0-g1)-dotalpha0*s*g1)/(2beta0*r)
   437386 dsdr0 = -(2k/r0^2*dsdbeta+g1/r)
   437386 dsda0 = -g2/r
   437386 dsdv0 = -2absv0*dsdbeta
   437386 dsdk = 2/r0*dsdbeta-g3/r
   437386 dbetadr0 = -2k/r0^2
   437386 dbetadv0 = -2absv0
   437386 dbetadk  = 2/r0
        - # "p" for partial derivative:
        - #pxpr0 = zeros(Float64,3); pxpa0=zeros(Float64,3); pxpk=zeros(Float64,3); pxps=zeros(Float64,3); pxpbeta=zeros(Float64,3)
        - #dxdr0 = zeros(Float64,3); dxda0=zeros(Float64,3); dxdk=zeros(Float64,3); dxdv0 =zeros(Float64,3)
        - #prvpr0 = zeros(Float64,3); prvpa0=zeros(Float64,3); prvpk=zeros(Float64,3); prvps=zeros(Float64,3); prvpbeta=zeros(Float64,3)
        - #drvdr0 = zeros(Float64,3); drvda0=zeros(Float64,3); drvdk=zeros(Float64,3); drvdv0=zeros(Float64,3)
        - #vtmp = zeros(Float64,3); dvdr0 = zeros(Float64,3); dvda0=zeros(Float64,3); dvdv0=zeros(Float64,3); dvdk=zeros(Float64,3)
   437386 for i=1:3
  1312158   pxpr0[i] = k/r0^2*g2*x0[i]+g1*v0[i]
  1312158   pxpa0[i] = g2*v0[i]
  1312158   pxpk[i]  = -g2/r0*x0[i]
  1312158   pxps[i]  = -k/r0*g1*x0[i]+(r0*g0+dotalpha0*g1)*v0[i]
  1312158   pxpbeta[i] = -k/(2beta0*r0)*(s*g1-2g2)*x0[i]+1/(2beta0)*(s*r0*g0-r0*g1+s*dotalpha0*g1-2*dotalpha0*g2)*v0[i]
  1312158   prvpr0[i] = k*g1/r0^2*x0[i]+g0*v0[i]
  1312158   prvpa0[i] = g1*v0[i]
  1312158   prvpk[i] = -g1/r0*x0[i]
  1312158   prvps[i] = -k*g0/r0*x0[i]+(-beta0*r0*g1+dotalpha0*g0)*v0[i]
  1312158   prvpbeta[i] = -k/(2beta0*r0)*(s*g0-g1)*x0[i]+1/(2beta0)*(-s*r0*beta0*g1+dotalpha0*s*g0-dotalpha0*g1)*v0[i]
        - end
   437386 prpr0 = g0
   437386 prpa0 = g1
   437386 prpk  = g2
   437386 prps = (k-beta0*r0)*g1+dotalpha0*g0
   437386 prpbeta = 1/(2beta0)*(s*(k-beta0*r0)*g1+dotalpha0*s*g0-dotalpha0*g1-2k*g2)
   437386 for i=1:3
  1312158   dxdr0[i] = pxps[i]*dsdr0 + pxpbeta[i]*dbetadr0 + pxpr0[i]
  1312158   dxda0[i] = pxps[i]*dsda0 + pxpa0[i]
  1312158   dxdv0[i] = pxps[i]*dsdv0 + pxpbeta[i]*dbetadv0
  1312158   dxdk[i]  = pxps[i]*dsdk  + pxpbeta[i]*dbetadk + pxpk[i]
  1312158   drvdr0[i] = prvps[i]*dsdr0 + prvpbeta[i]*dbetadr0 + prvpr0[i]
  1312158   drvda0[i] = prvps[i]*dsda0 + prvpa0[i]
  1312158   drvdv0[i] = prvps[i]*dsdv0 + prvpbeta[i]*dbetadv0
  1312158   drvdk[i]  = prvps[i]*dsdk  + prvpbeta[i]*dbetadk +prvpk[i]
        - end
   437386 drdr0 = prpr0 + prps*dsdr0 + prpbeta*dbetadr0
   437386 drda0 = prpa0 + prps*dsda0
   437386 drdv0 = prps*dsdv0 + prpbeta*dbetadv0
   437386 drdk  = prpk + prps*dsdk + prpbeta*dbetadk
   437386 for i=1:3
  1312158   vtmp[i] = dfdt*x0[i]+dgdt*v0[i]
  1312158   dvdr0[i] = (drvdr0[i]-drdr0*vtmp[i])/r
  1312158   dvda0[i] = (drvda0[i]-drda0*vtmp[i])/r
  1312158   dvdv0[i] = (drvdv0[i]-drdv0*vtmp[i])/r
  1312158   dvdk[i]  = (drvdk[i] -drdk *vtmp[i])/r
        - end
        - # Now, compute Jacobian:
   437386 for i=1:3
  1312158   jacobian[  i,  i] = f
  1312158   jacobian[  i,3+i] = g
  1312158   jacobian[3+i,  i] = dfdt
  1312158   jacobian[3+i,3+i] = dgdt
  1312158   jacobian[  i,7] = dxdk[i]
  1312158   jacobian[3+i,7] = dvdk[i]
  1312158   for j=1:3
  3936474     jacobian[  i,  j] += dxdr0[i]*x0[j]/r0
  3936474     jacobian[  i,  j] += dxda0[i]*v0[j]
  3936474     jacobian[  i,3+j] += dxdv0[i]*v0[j]/absv0
  3936474     jacobian[  i,3+j] += dxda0[i]*x0[j]
  3936474     jacobian[3+i,  j] += dvdr0[i]*x0[j]/r0
  3936474     jacobian[3+i,  j] += dvda0[i]*v0[j]
  3936474     jacobian[3+i,3+j] += dvdv0[i]*v0[j]/absv0
  3936474     jacobian[3+i,3+j] += dvda0[i]*x0[j]
        -   end
  1312158   jacobian[7,7]=1.0
        - end
   437386 return
        - end
        - 
