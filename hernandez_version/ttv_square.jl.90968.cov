        - # Translation of David Hernandez's nbody.c for integrating hiercharical
        - # system with BH15 integrator.  Please cite Hernandez & Bertschinger (2015)
        - # if using this in a paper.
        - 
        - const YEAR  = 365.242
        - const GNEWT = 39.4845/YEAR^2
        - const NDIM  = 3
        - const KEPLER_TOL = 1e-8
        - const third = 1./3.
        - const alpha0 = 0.0
        - include("kepler_step.jl")
        - include("init_nbody.jl")
        - const pxpr0 = zeros(Float64,3);const  pxpa0=zeros(Float64,3);const  pxpk=zeros(Float64,3);const  pxps=zeros(Float64,3);const  pxpbeta=zeros(Float64,3)
        - const dxdr0 = zeros(Float64,3);const  dxda0=zeros(Float64,3);const  dxdk=zeros(Float64,3);const  dxdv0 =zeros(Float64,3)
        - const prvpr0 = zeros(Float64,3);const  prvpa0=zeros(Float64,3);const  prvpk=zeros(Float64,3);const  prvps=zeros(Float64,3);const  prvpbeta=zeros(Float64,3)
        - const drvdr0 = zeros(Float64,3);const  drvda0=zeros(Float64,3);const  drvdk=zeros(Float64,3);const  drvdv0=zeros(Float64,3)
        - const vtmp = zeros(Float64,3);const  dvdr0 = zeros(Float64,3);const  dvda0=zeros(Float64,3);const  dvdv0=zeros(Float64,3);const  dvdk=zeros(Float64,3)
        - 
        - const state0 = zeros(Float64,12); state = zeros(Float64,12); delx = zeros(Float64,NDIM); delv = zeros(Float64,NDIM); xcm = zeros(Float64,NDIM); vcm = zeros(Float64,NDIM)
        - 
        - function ttv!(n::Int64,t0::Float64,h::Float64,tmax::Float64,elements::Array{Float64,2},tt::Array{Float64,2},count::Array{Int64,1},dtdq0::Array{Float64,4})
        - #fcons = open("fcons.txt","w");
        3 m=zeros(Float64,n)
        3 x=zeros(Float64,NDIM,n)
        3 v=zeros(Float64,NDIM,n)
        - # Fill the transit-timing & jacobian arrays with zeros:
        3 fill!(tt,0.0)
        3 fill!(dtdq0,0.0)
        - # Counter for transits of each planet:
        3 fill!(count,0)
        3 for i=1:n
       24   m[i] = elements[i,1]
        - end
        - # Initialize the N-body problem using nested hierarchy of Keplerians:
        3 x,v = init_nbody(elements,t0,n)
        3 xprior = copy(x)
        3 vprior = copy(v)
        - xtransit = copy(x)
        3 vtransit = copy(v)
        - # Set the time to the initial time:
        3 t = t0
        - # Set step counter to zero:
        - istep = 0
        3 # Jacobian for each step (7- 6 elements+mass, n_planets, 7 - 6 elements+mass, n planets):
        3 #jac_step = zeros(Float64,7*n,7*n)
        - jac_prior = zeros(Float64,7*n,7*n)
        3 jac_transit = zeros(Float64,7*n,7*n)
        - dtdq = zeros(Float64,7,n)
        - # Initialize the Jacobian to the identity matrix:
        - jac_step = eye(Float64,7*n)
        3 
        - # Save the g function, which computes the relative sky velocity dotted with relative position
        3 # between the planets and star:
        3 gsave = zeros(Float64,n)
        3 # Loop over time steps:
        - dt::Float64 = 0.0
        - gi = 0.0
    24003 while t < t0+tmax
        -   # Carry out a phi^2 mapping step:
        - #  phi2!(x,v,h,m,n)
        -   dh17!(x,v,h,m,n,jac_step)
    24003   # Check to see if a transit may have occured.  Sky is x-y plane; line of sight is z.
        -   # Star is body 1; planets are 2-nbody (note that this could be modified to see if
   168021   # any body transits another body):
   168021   for i=2:n
        -     # Compute the relative sky velocity dotted with position:
   168021     gi = g!(i,1,x,v)
        -     ri = sqrt(x[1,i]^2+x[2,i]^2+x[3,i]^2)
        -     # See if sign switches, and if planet is in front of star (by a good amount):
     3108     if gi > 0 && gsave[i] < 0 && x[3,i] > 0.25*ri
        -       # A transit has occurred between the time steps.
     3108       # Approximate the planet-star motion as a Keplerian, weighting over timestep:
        -       count[i] += 1
     3108 #      tt[i,count[i]]=t+findtransit!(i,h,gi,gsave[i],m,xprior,vprior,x,v)
     3108       dt = -gsave[i]*h/(gi-gsave[i])
     3108 #      dt = findtransit2!(1,i,h,dt,m,xprior,vprior)
     3108       xtransit .= xprior
     3108       vtransit .= vprior
        -       jac_transit .= jac_prior
     3108       dt = findtransit2!(1,i,h,dt,m,xtransit,vtransit,jac_transit,dtdq) # 20%
   174048       tt[i,count[i]]=t+dt
        -       # Save for posterity:
        -       for k=1:7, p=1:n
   168021         dtdq0[i,count[i],k,p] = dtdq[k,p]
        -       end
        -     end
    24003     gsave[i] = gi
    24003   end
    24003   # Save the current state as prior state:
        -   xprior .= x
    24003   vprior .= v
        -   jac_prior .= jac_step
    24003   # Increment time by the time step:
        -   t += h
        3   # Increment counter by one:
        -   istep +=1
        - end
        - return 
        - end
        3 
        3 function ttv!(n::Int64,t0::Float64,h::Float64,tmax::Float64,elements::Array{Float64,2},tt::Array{Float64,2},count::Array{Int64,1},dlnq::Float64,iq::Int64,jq::Int64)
        3 #fcons = open("fcons.txt","w");
        - m=zeros(Float64,n)
        3 x=zeros(Float64,NDIM,n)
        - v=zeros(Float64,NDIM,n)
        3 # Fill the transit-timing array with zeros:
        3 fill!(tt,0.0)
       24 # Counter for transits of each planet:
        - fill!(count,0)
        - for i=1:n
        -   m[i] = elements[i,1]
        3 end
        3 # Allow for perturbations to initial conditions: jq labels body; iq labels phase-space element (or mass)
        0 # iq labels phase-space element (1-3: x; 4-6: v; 7: m)
        0 dq = 0.0
        - if iq == 7 && dlnq != 0.0
        -   dq = m[jq]*dlnq
        3   m[jq] += dq
        - end
        3 # Initialize the N-body problem using nested hierarchy of Keplerians:
        0 x,v = init_nbody(elements,t0,n)
        0 # Perturb the initial condition by an amount dlnq (if it is non-zero):
        0 if dlnq != 0.0 && iq > 0 && iq < 7
        -   if iq < 4
        0     if x[iq,jq] != 0
        -       dq = x[iq,jq]*dlnq
        0     else
        -       dq = dlnq
        -     end
        0     x[iq,jq] += dq
        0   else
        -   # Same for v
        0     if v[iq-3,jq] != 0
        -       dq = v[iq-3,jq]*dlnq
        0     else
        -       dq = dlnq
        -     end
        3     v[iq-3,jq] += dq
        3   end
        - end
        3 xprior = copy(x)
        - vprior = copy(v)
        3 xtransit = copy(x)
        - vtransit = copy(v)
        - # Set the time to the initial time:
        - t = t0
        3 # Set step counter to zero:
        3 istep = 0
        3 # Jacobian for each step (7 elements+mass, n_planets, 7 elements+mass, n planets):
        - # Save the g function, which computes the relative sky velocity dotted with relative position
        3 # between the planets and star:
        - gsave = zeros(Float64,n)
        - gi  = 0.0
    96003 dt::Float64 = 0.0
        - # Loop over time steps:
        - while t < t0+tmax
    96003   # Carry out a phi^2 mapping step:
        - #  phi2!(x,v,h,m,n)
   672021   dh17!(x,v,h,m,n)
   672021   # Check to see if a transit may have occured.  Sky is x-y plane; line of sight is z.
        -   # Star is body 1; planets are 2-nbody:
   672021   for i=2:n
        -     # Compute the relative sky velocity dotted with position:
        -     gi = g!(i,1,x,v)
     3108     ri = sqrt(x[1,i]^2+x[2,i]^2+x[3,i]^2)
        -     # See if sign switches, and if planet is in front of star (by a good amount):
     3108     if gi > 0 && gsave[i] < 0 && x[3,i] > 0.25*ri
     3108       # A transit has occurred between the time steps.
     3108       # Approximate the planet-star motion as a Keplerian, weighting over timestep:
     3108       count[i] += 1
     3108 #      tt[i,count[i]]=t+findtransit!(i,h,gi,gsave[i],m,xprior,vprior,x,v)
        -       dt = -gsave[i]*h/(gi-gsave[i])
        -       xtransit .= xprior
   672021       vtransit .= vprior
        -       dt = findtransit2!(1,i,h,dt,m,xtransit,vtransit)
        -       tt[i,count[i]]=t+dt
    96003 #      tt[i,count[i]]=t+findtransit2!(1,i,h,gi,gsave[i],m,xprior,vprior)
    96003     end
        -     gsave[i] = gi
    96003   end
        -   # Save the current state as prior state:
    96003   xprior .=x
        -   vprior .=v
        3   # Increment time by the time step:
        -   t += h
        -   # Increment counter by one:
        -   istep +=1
        - end
  7582232 return dq
 22746696 end
 22746696 
 22746696 # Advances the center of mass of a binary
 22746696 function centerm!(m::Array{Float64,1},mijinv::Float64,x::Array{Float64,2},v::Array{Float64,2},vcm::Array{Float64,1},delx::Array{Float64,1},delv::Array{Float64,1},i::Int64,j::Int64,h::Float64)
        - for k=1:NDIM
  7582232   x[k,i] +=  m[j]*mijinv*delx[k] + h*vcm[k]
        -   x[k,j] += -m[i]*mijinv*delx[k] + h*vcm[k]
        -   v[k,i] +=  m[j]*mijinv*delv[k]
        -   v[k,j] += -m[i]*mijinv*delv[k]
        - end
        - return
  6064016 end
 18192048 
 18192048 
        - # Drifts bodies i & j
  6064016 function driftij!(x::Array{Float64,2},v::Array{Float64,2},i::Int64,j::Int64,h::Float64)
        - for k=1:NDIM
        -   x[k,i] += h*v[k,i]
        -   x[k,j] += h*v[k,j]
        - end
  1518216 return
  1518216 end
  1518216 
  4554648 # Drifts bodies i & j
  4554648 function driftij!(x::Array{Float64,2},v::Array{Float64,2},i::Int64,j::Int64,h::Float64,jac_step::Array{Float64,2},nbody::Int64)
        - indi = (i-1)*7
  4554648 indj = (j-1)*7
255060288 for k=1:NDIM
255060288   x[k,i] += h*v[k,i]
        -   x[k,j] += h*v[k,j]
        -   # Now for Jacobian:
  1518216   for m=1:7*nbody
        -     jac_step[indi+k,m] += h*jac_step[indi+3+k,m]
        -     jac_step[indj+k,m] += h*jac_step[indj+3+k,m]
        -   end    
        - end
        - return
        - end
  6064016 
        - # Carries out a Kepler step for bodies i & j
  6064016 function keplerij!(m::Array{Float64,1},x::Array{Float64,2},v::Array{Float64,2},i::Int64,j::Int64,h::Float64)
  6064016 # The state vector has: 1 time; 2-4 position; 5-7 velocity; 8 r0; 9 dr0dt; 10 beta; 11 s; 12 ds
  6064016 # Initial state:
        - state0 = zeros(Float64,12)
  6064016 # Final state (after a step):
 18192048 state = zeros(Float64,12)
 18192048 delx = zeros(Float64,NDIM)
        - delv = zeros(Float64,NDIM)
  6064016 #println("Masses: ",i," ",j)
  6064016 for k=1:NDIM
        0   state0[1+k     ] = x[k,i] - x[k,j]
        0   state0[1+k+NDIM] = v[k,i] - v[k,j]
        0 end
        - gm = GNEWT*(m[i]+m[j])
        - if gm == 0
        -   for k=1:NDIM
  6064016     x[k,i] += h*v[k,i]
  6064016     x[k,j] += h*v[k,j]
  6064016   end
 18192048 else
 18192048   # predicted value of s
        -   state0[11]=0.0
        -   kepler_step!(gm, h, state0, state)
        -   for k=1:NDIM
  6064016     delx[k] = state[1+k] - state0[1+k]
  6064016     delv[k] = state[1+NDIM+k] - state0[1+NDIM+k]
  6064016   end
 18192048 # Advance center of mass:
        - # Compute COM coords:
  6064016   mijinv =1.0/(m[i] + m[j])
        -   vcm = zeros(Float64,NDIM)
  6064016   for k=1:NDIM
        -     vcm[k] = (m[i]*v[k,i] + m[j]*v[k,j])*mijinv
        -   end
        -   centerm!(m,mijinv,x,v,vcm,delx,delv,i,j,h)
        - end
        - return
        - end
  1518216 
        - # Carries out a Kepler step for bodies i & j
  1518216 function keplerij!(m::Array{Float64,1},x::Array{Float64,2},v::Array{Float64,2},i::Int64,j::Int64,h::Float64,jac_ij::Array{Float64,2})
  1518216 # The state vector has: 1 time; 2-4 position; 5-7 velocity; 8 r0; 9 dr0dt; 10 beta; 11 s; 12 ds
  1518216 # Initial state:
        - state0 = zeros(Float64,12)
        - # Final state (after a step):
        - state = zeros(Float64,12)
  1518216 delx = zeros(Float64,NDIM)
  1518216 delv = zeros(Float64,NDIM)
  4554648 # jac_ij should be the Jacobian for going from (x_{0,i},v_{0,i},m_i) &  (x_{0,j},v_{0,j},m_j)
  4554648 # to  (x_i,v_i,m_i) &  (x_j,v_j,m_j), a 14x14 matrix for the 3-dimensional case. 
        - # Fill with zeros for now:
  1518216 fill!(jac_ij,0.0)
        - for k=1:NDIM
        -   state0[1+k     ] = x[k,i] - x[k,j]
  1518216   state0[1+k+NDIM] = v[k,i] - v[k,j]
  1518216 end
  1518216 gm = GNEWT*(m[i]+m[j])
  4554648 # The following jacobian is just computed for the Keplerian coordinates (i.e. doesn't include
  4554648 # center-of-mass motion, or scale to motion of bodies about their common center of mass):
        - jac_kepler = zeros(Float64,7,7)
        - kepler_step!(gm, h, state0, state, jac_kepler)
  1518216 for k=1:NDIM
  1518216   delx[k] = state[1+k] - state0[1+k]
  1518216   delv[k] = state[1+NDIM+k] - state0[1+NDIM+k]
  1518216 end
  1518216 # Compute COM coords:
        - mijinv =1.0/(m[i] + m[j])
  1518216 xcm = zeros(Float64,NDIM)
  4554648 vcm = zeros(Float64,NDIM)
  4554648 mi = m[i]*mijinv # Normalize the masses
        - mj = m[j]*mijinv
        - #println("Masses: ",i," ",j)
  1518216 for k=1:NDIM
  1518216   xcm[k] = mi*x[k,i] + mj*x[k,j]
  1518216   vcm[k] = mi*v[k,i] + mj*v[k,j]
  4554648 end
  4554648 # Compute the Jacobian:
  4554648 jac_ij[ 7, 7] = 1.0  # the masses don't change with time!
  4554648 jac_ij[14,14] = 1.0
  4554648 for k=1:NDIM
  4554648    jac_ij[   k,   k] +=   mi
  4554648    jac_ij[   k, 3+k] += h*mi
  4554648    jac_ij[   k, 7+k] +=   mj
  4554648    jac_ij[   k,10+k] += h*mj
  4554648    jac_ij[ 3+k, 3+k] +=   mi
  4554648    jac_ij[ 3+k,10+k] +=   mj
  4554648    jac_ij[ 7+k,   k] +=   mi
  4554648    jac_ij[ 7+k, 3+k] += h*mi
        -    jac_ij[ 7+k, 7+k] +=   mj
 13663944    jac_ij[ 7+k,10+k] += h*mj
 13663944    jac_ij[10+k, 3+k] +=   mi
 13663944    jac_ij[10+k,10+k] +=   mj
 13663944 end
        - for l=1:NDIM, k=1:NDIM
 13663944 # Compute derivatives of \delta x_i with respect to initial conditions:
 13663944      jac_ij[   k,   l] += mj*jac_kepler[  k,  l]
 13663944      jac_ij[   k, 3+l] += mj*jac_kepler[  k,3+l]
 13663944      jac_ij[   k, 7+l] -= mj*jac_kepler[  k,  l]
        -      jac_ij[   k,10+l] -= mj*jac_kepler[  k,3+l]
 13663944 # Compute derivatives of \delta v_i with respect to initial conditions:
 13663944      jac_ij[ 3+k,   l] += mj*jac_kepler[3+k,  l]
 13663944      jac_ij[ 3+k, 3+l] += mj*jac_kepler[3+k,3+l]
 13663944      jac_ij[ 3+k, 7+l] -= mj*jac_kepler[3+k,  l]
        -      jac_ij[ 3+k,10+l] -= mj*jac_kepler[3+k,3+l]
 13663944 # Compute derivatives of \delta x_j with respect to initial conditions:
 13663944      jac_ij[ 7+k,   l] -= mi*jac_kepler[  k,  l]
 13663944      jac_ij[ 7+k, 3+l] -= mi*jac_kepler[  k,3+l]
 13663944      jac_ij[ 7+k, 7+l] += mi*jac_kepler[  k,  l]
        -      jac_ij[ 7+k,10+l] += mi*jac_kepler[  k,3+l]
        - # Compute derivatives of \delta v_j with respect to initial conditions:
  4554648      jac_ij[10+k,   l] -= mi*jac_kepler[3+k,  l]
  4554648      jac_ij[10+k, 3+l] -= mi*jac_kepler[3+k,3+l]
        -      jac_ij[10+k, 7+l] += mi*jac_kepler[3+k,  l]
  4554648      jac_ij[10+k,10+l] += mi*jac_kepler[3+k,3+l]
  4554648 end
        - for k=1:NDIM
  4554648 # Compute derivatives of \delta x_i with respect to the masses:
  4554648    jac_ij[   k, 7] += (x[k,i]+h*v[k,i]-xcm[k]-h*vcm[k]-mj*state[1+k])*mijinv + GNEWT*mj*jac_kepler[  k,7]
        -    jac_ij[   k,14] += (x[k,j]+h*v[k,j]-xcm[k]-h*vcm[k]+mi*state[1+k])*mijinv + GNEWT*mj*jac_kepler[  k,7]
  4554648 # Compute derivatives of \delta v_i with respect to the masses:
  4554648    jac_ij[ 3+k, 7] += (v[k,i]-vcm[k]-mj*state[4+k])*mijinv + GNEWT*mj*jac_kepler[3+k,7]
        -    jac_ij[ 3+k,14] += (v[k,j]-vcm[k]+mi*state[4+k])*mijinv + GNEWT*mj*jac_kepler[3+k,7]
        - # Compute derivatives of \delta x_j with respect to the masses:
  1518216    jac_ij[ 7+k, 7] += (x[k,i]+h*v[k,i]-xcm[k]-h*vcm[k]-mj*state[1+k])*mijinv - GNEWT*mi*jac_kepler[  k,7]
  1518216    jac_ij[ 7+k,14] += (x[k,j]+h*v[k,j]-xcm[k]-h*vcm[k]+mi*state[1+k])*mijinv - GNEWT*mi*jac_kepler[  k,7]
        - # Compute derivatives of \delta v_j with respect to the masses:
        -    jac_ij[10+k, 7] += (v[k,i]-vcm[k]-mj*state[4+k])*mijinv - GNEWT*mi*jac_kepler[3+k,7]
        -    jac_ij[10+k,14] += (v[k,j]-vcm[k]+mi*state[4+k])*mijinv - GNEWT*mi*jac_kepler[3+k,7]
        - end
   216572 # Advance center of mass & individual Keplerian motions:
  5197728 centerm!(m,mijinv,x,v,vcm,delx,delv,i,j,h)
        - return
   216572 end
        - 
        - # Drifts all particles:
        - function drift!(x::Array{Float64,2},v::Array{Float64,2},h::Float64,n::Int64)
        - for i=1:n, j=1:NDIM
    54222   x[j,i] += h*v[j,i]
    54222 end
   433776 return
   433776 end
  1301328 
        - # Drifts all particles:
  1301328 function drift!(x::Array{Float64,2},v::Array{Float64,2},h::Float64,n::Int64,jac_step::Array{Float64,2})
 72874368 indi = 0
        - for i=1:n
        -   indi = (i-1)*7
        -   for j=1:NDIM
    54222     x[j,i] += h*v[j,i]
        -     # Now for Jacobian:
        -     for k=1:7*n
        -       jac_step[indi+j,k] += h*jac_step[indi+3+j,k]
        -     end    
        -   end
        - end
   108286 return
   108286 end
   108286 
   108286 function phisalpha!(x::Array{Float64,2},v::Array{Float64,2},h::Float64,m::Array{Float64,1},alpha::Float64,n::Int64)
   649716 # Computes the 4th-order correction:
   108286 #function [v] = phisalpha(x,v,h,m,alpha)
   866288 #n = size(m,2);
  3032008 a = zeros(Float64,3,n)
  9096024 rij = zeros(Float64,3)
        - aij = zeros(Float64,3)
  3032008 coeff = alpha*h^3/96*2*GNEWT
  3032008 fac = 0.0; fac1 = 0.0; fac2 = 0.0; r1 = 0.0; r2 = 0.0; r3 = 0.0
  3032008 for i=1:n
  9096024   for j = i+1:n
  9096024     for k=1:3
  9096024       rij[k] = x[k,i] - x[k,j]
        -     end
        -     r2 = rij[1]*rij[1]+rij[2]*rij[2]+rij[3]*rij[3]
        -     r3 = r2*sqrt(r2)
        -     for k=1:3
        -       fac = GNEWT*rij[k]/r3
   108286       a[k,i] -= m[j]*fac
   866288       a[k,j] += m[i]*fac
  3032008     end
  9096024   end
        - end
  9096024 # Next, compute \tilde g_i acceleration vector (this is rewritten
        - # slightly to avoid reference to \tilde a_i):
  3032008 for i=1:n
  3032008   for j=i+1:n
  3032008     for k=1:3
  3032008       aij[k] = a[k,i] - a[k,j]
  3032008 #      aij[k] = 0.0
  3032008       rij[k] = x[k,i] - x[k,j]
        -     end
  9096024     r2 = rij[1]*rij[1]+rij[2]*rij[2]+rij[3]*rij[3]
  9096024     r1 = sqrt(r2)
  9096024     ardot = aij[1]*rij[1]+aij[2]*rij[2]+aij[3]*rij[3]
        -     fac1 = coeff/r1^5
        -     fac2 = (2*GNEWT*(m[i]+m[j])/r1 + 3*ardot) 
        -     for k=1:3
   108286 #      fac = coeff/r1^5*(rij[k]*(2*GNEWT*(m[i]+m[j])/r1 + 3*ardot) - r2*aij[k])
        -       fac = fac1*(rij[k]*fac2- r2*aij[k])
        -       v[k,i] += m[j]*fac
        -       v[k,j] -= m[i]*fac
        -     end
        -   end
        - end
    27111 return
    27111 end
    27111 
    27111 function phisalpha!(x::Array{Float64,2},v::Array{Float64,2},h::Float64,m::Array{Float64,1},alpha::Float64,n::Int64,jac_step::Array{Float64,2})
    27111 # Computes the 4th-order correction:
    27111 #function [v] = phisalpha(x,v,h,m,alpha)
   189777 #n = size(m,2);
    27111 a = zeros(Float64,3,n)
   189777 dadq = zeros(Float64,3,n,4,n)  # There is no velocity dependence
   759108 dotdadq = zeros(Float64,4,n)  # There is no velocity dependence
  2277324 rij = zeros(Float64,3)
        - aij = zeros(Float64,3)
   759108 coeff = alpha*h^3/96*2*GNEWT
   759108 fac = 0.0; fac1 = 0.0; fac2 = 0.0; fac3 = 0.0; r1 = 0.0; r2 = 0.0; r3 = 0.0
   759108 for i=1:n-1
  2277324   for j = i+1:n
  2277324     for k=1:3
  2277324       rij[k] = x[k,i] - x[k,j]
        -     end
        -     r2 = rij[1]*rij[1]+rij[2]*rij[2]+rij[3]*rij[3]
        -     r3 = r2*sqrt(r2)
  2277324     for k=1:3
  2277324       fac = GNEWT*rij[k]/r3
        -       a[k,i] -= m[j]*fac
  2277324       a[k,j] += m[i]*fac
        -       # Mass derivative of acceleration vector (10/6/17 notes):
  2277324       # Since there is no velocity dependence, this is fourth parameter.
  6831972       # Acceleration of ith particle depends on mass of jth particle:
  6831972       dadq[k,i,4,j] -= fac
  6831972       dadq[k,j,4,i] += fac
  6831972       # x derivative of acceleration vector:
        -       fac *= 3.0/r2
        -       # Dot product x_ij.\delta x_ij means we need to sum over components:
  2277324       for p=1:3
  2277324         dadq[k,i,p,i] += fac*m[j]*rij[p]
  2277324         dadq[k,i,p,j] -= fac*m[j]*rij[p]
  2277324         dadq[k,j,p,j] += fac*m[i]*rij[p]
  2277324         dadq[k,j,p,i] -= fac*m[i]*rij[p]
        -       end
        -       # Final term has no dot product, so just diagonal:
        -       fac = GNEWT/r3
        -       dadq[k,i,k,i] -= fac*m[j]
        -       dadq[k,i,k,j] += fac*m[j]
        -       dadq[k,j,k,j] -= fac*m[i]
        -       dadq[k,j,k,i] += fac*m[i]
    27111     end
        -   end
        - end
    27111 # Delete this when finished debugging:
   189777 #fill!(dadq,0.0)
   759108 # Next, compute \tilde g_i acceleration vector (this is rewritten
  2277324 # slightly to avoid reference to \tilde a_i):
        - fill!(jac_step,0.0)
  2277324 # Note that jac_step[(i-1)*7+k,(j-1)*7+p] is the derivative of the kth coordinate
        - # of planet i with respect to the pth coordinate of planet j.
        - for i=1:n-1
   759108   for j=i+1:n
   759108     for k=1:3
 72874368       aij[k] = a[k,i] - a[k,j]
        - #      aij[k] = 0.0
   759108       rij[k] = x[k,i] - x[k,j]
   759108     end
   759108     # Compute dot product of r_ij with \delta a_ij:
   759108     fill!(dotdadq,0.0)
   759108     for d=1:n, p=1:4, k=1:3
   759108       dotdadq[p,d] += rij[k]*(dadq[k,i,p,d]-dadq[k,j,p,d])
        -     end
  2277324     r2 = rij[1]*rij[1]+rij[2]*rij[2]+rij[3]*rij[3]
  2277324     r1 = sqrt(r2)
  2277324     ardot = aij[1]*rij[1]+aij[2]*rij[2]+aij[3]*rij[3]
        -     fac1 = coeff/r1^5
  2277324     fac2 = (2*GNEWT*(m[i]+m[j])/r1 + 3*ardot) 
  2277324     for k=1:3
        - #      fac = coeff/r1^5*(rij[k]*(2*GNEWT*(m[i]+m[j])/r1 + 3*ardot) - r2*aij[k])
  2277324       fac = fac1*(rij[k]*fac2- r2*aij[k])
  2277324       v[k,i] += m[j]*fac
  6831972       v[k,j] -= m[i]*fac
  6831972       # Mass derivative (first part is easy):
  6831972       jac_step[(i-1)*7+3+k,(j-1)*7+7] += fac
  6831972       jac_step[(j-1)*7+3+k,(i-1)*7+7] -= fac
        -       # Position derivatives:
        -       fac *= 5.0/r2
  2277324       for p=1:3
  2277324         jac_step[(i-1)*7+3+k,(i-1)*7+p] -= fac*m[j]*rij[p]
  2277324         jac_step[(i-1)*7+3+k,(j-1)*7+p] += fac*m[j]*rij[p]
  2277324         jac_step[(j-1)*7+3+k,(j-1)*7+p] -= fac*m[i]*rij[p]
  2277324         jac_step[(j-1)*7+3+k,(i-1)*7+p] += fac*m[i]*rij[p]
        -       end
        -       # Second mass derivative:
  2277324       fac = 2*GNEWT*fac1*rij[k]/r1
  2277324       jac_step[(i-1)*7+3+k,(i-1)*7+7] += fac*m[j]
  2277324       jac_step[(i-1)*7+3+k,(j-1)*7+7] += fac*m[j]
  2277324       jac_step[(j-1)*7+3+k,(j-1)*7+7] -= fac*m[i]
  2277324       jac_step[(j-1)*7+3+k,(i-1)*7+7] -= fac*m[i]
        -       #  (There's also a mass term in dadq [x]. See below.)
  2277324       # Diagonal position terms:
  2277324       fac = fac1*fac2
  6831972       jac_step[(i-1)*7+3+k,(i-1)*7+k] += fac*m[j]
  6831972       jac_step[(i-1)*7+3+k,(j-1)*7+k] -= fac*m[j]
  6831972       jac_step[(j-1)*7+3+k,(j-1)*7+k] += fac*m[i]
  6831972       jac_step[(j-1)*7+3+k,(i-1)*7+k] -= fac*m[i]
  6831972       # Dot product \delta rij terms:
        -       fac = -2*fac1*(rij[k]*GNEWT*(m[i]+m[j])/(r2*r1)+aij[k])
        -       for p=1:3
  2277324         fac3 = fac*rij[p] + fac1*3.0*rij[k]*aij[p]
        -         jac_step[(i-1)*7+3+k,(i-1)*7+p] += m[j]*fac3
  2277324         jac_step[(i-1)*7+3+k,(j-1)*7+p] -= m[j]*fac3
 18218592         jac_step[(j-1)*7+3+k,(j-1)*7+p] += m[i]*fac3
 54655776         jac_step[(j-1)*7+3+k,(i-1)*7+p] -= m[i]*fac3
 54655776       end
        -       # Diagonal acceleration terms:
        -       fac = -fac1*r2
 18218592       # Duoh.  For dadq, have to loop over all other parameters!
 18218592       for d=1:n
        -         for p=1:3
        -           jac_step[(i-1)*7+3+k,(d-1)*7+p] += fac*m[j]*(dadq[k,i,p,d]-dadq[k,j,p,d])
  2277324           jac_step[(j-1)*7+3+k,(d-1)*7+p] -= fac*m[i]*(dadq[k,i,p,d]-dadq[k,j,p,d])
  2277324         end
 18218592         # Don't forget mass-dependent term:
 54655776         jac_step[(i-1)*7+3+k,(d-1)*7+7] += fac*m[j]*(dadq[k,i,4,d]-dadq[k,j,4,d])
 54655776         jac_step[(j-1)*7+3+k,(d-1)*7+7] -= fac*m[i]*(dadq[k,i,4,d]-dadq[k,j,4,d])
        -       end
 18218592       # Now, for the final term:  (\delta a_ij . r_ij ) r_ij
 18218592       fac = 3.*fac1*rij[k]
        -       for d=1:n
        -         for p=1:3
        -           jac_step[(i-1)*7+3+k,(d-1)*7+p] += fac*m[j]*dotdadq[p,d]
        -           jac_step[(j-1)*7+3+k,(d-1)*7+p] -= fac*m[i]*dotdadq[p,d]
    27111         end
   216888         jac_step[(i-1)*7+3+k,(d-1)*7+7] += fac*m[j]*dotdadq[4,d]
        -         jac_step[(j-1)*7+3+k,(d-1)*7+7] -= fac*m[i]*dotdadq[4,d]
   650664       end
        -     end
   650664   end
        - end
        - for i=1:n
   216888   for k=1:3
        -   # Position remains unchanged, so Jacobian of position should be identity matrix:
    27111     jac_step[(i-1)*7+  k,(i-1)*7+  k] += 1.0
        -   # Jacobian of velocity has linear dependence on initial velocity
        -     jac_step[(i-1)*7+3+k,(i-1)*7+3+k] += 1.0
        -   end
        -   # Mass remains unchanged:
   108286   jac_step[(i-1)*7+7,(i-1)*7+7] += 1.0
   108286 end
        - return
   108286 end
        0 
        - # Carries out the DH17 mapping
   108286 function dh17!(x::Array{Float64,2},v::Array{Float64,2},h::Float64,m::Array{Float64,1},n::Int64)
   108286 alpha = alpha0
   758002 h2 = 0.5*h
  3032008 # alpha = 0. is similar in precision to alpha=0.25
  3032008 if alpha != 0.0
        -   phisalpha!(x,v,h,m,alpha,n)
        - end
   108286 drift!(x,v,h2,n)
   108286 for i=1:n-1
        -   for j=i+1:n
   108286     driftij!(x,v,i,j,-h2)
   758002     keplerij!(m,x,v,i,j,h2)
  3032008   end
  3032008 end
        - if alpha != 1.0
        -   phisalpha!(x,v,h,m,2.*(1.-alpha),n)
   108286 end
   108286 for i=n-1:-1:1
        0   for j=n:-1:i+1
        -     keplerij!(m,x,v,i,j,h2)
   108286     driftij!(x,v,i,j,-h2)
        -   end
        - end
        - drift!(x,v,h2,n)
        - if alpha != 0.0
        -   phisalpha!(x,v,h,m,alpha,n)
   855433 end
   855433 return
        - end
        - 
        - # Used in computing the transit time:
        - function g!(i::Int64,j::Int64,x::Array{Float64,2},v::Array{Float64,2})
    27111 # See equation 8-10 Fabrycky (2008) in Seager Exoplanets book
    27111 g = (x[1,j]-x[1,i])*(v[1,j]-v[1,i])+(x[2,j]-x[2,i])*(v[2,j]-v[2,i])
    27111 return g
    27111 end
    27111 
        - # Carries out the DH17 mapping & computes the jacobian:
    27111 function dh17!(x::Array{Float64,2},v::Array{Float64,2},h::Float64,m::Array{Float64,1},n::Int64,jac_step::Array{Float64,2})
        0 h2 = 0.5*h
        0 alpha = alpha0
        - jac_phi = zeros(Float64,7*n,7*n)
    27111 jac_tmp = zeros(Float64,7*n,7*n)
    27111 jac_step_ij = zeros(Float64,14,7*n)
    27111 # alpha = 0. is similar in precision to alpha=0.25
   189777 if alpha != 0.0
   759108   phisalpha!(x,v,h,m,alpha,n,jac_phi)
   759108   jac_step .= jac_phi*jac_step # < 1%
   759108 end
297570336 drift!(x,v,h2,n,jac_step)
297570336 jac_ij = zeros(Float64,14,14)
        - for i=1:n-1
   759108   for j=i+1:n
   759108     driftij!(x,v,i,j,-h2,jac_step,n)
297570336     keplerij!(m,x,v,i,j,h2,jac_ij) # 21%
297570336     for k1=1:7, k2=1:7*n
        -       jac_step_ij[  k1,k2]=jac_step[(i-1)*7+k1,k2]
        -       jac_step_ij[7+k1,k2]=jac_step[(j-1)*7+k1,k2]
        -     end
    27111     jac_step_ij .= *(jac_ij,jac_step_ij)
    27111     for k1=1:7, k2=1:7*n
    27111       jac_step[(i-1)*7+k1,k2]=jac_step_ij[  k1,k2]
        -       jac_step[(j-1)*7+k1,k2]=jac_step_ij[7+k1,k2]
    54222     end
    27111   end
   189777 end
   189777 if alpha != 1.0
   759108   phisalpha!(x,v,h,m,2.*(1.-alpha),n,jac_phi) # 10%
   759108   jac_step .= jac_phi*jac_step # < 1%
   759108 end
297570336 indi=0; indj=0
297570336 for i=n-1:-1:1
        -   indi=(i-1)*7
   759108   for j=n:-1:i+1
   759108     indj=(j-1)*7
297570336     keplerij!(m,x,v,i,j,h2,jac_ij) # 23%
297570336     for k2=1:7*n, k1=1:7
        -       jac_step_ij[  k1,k2]=jac_step[indi+k1,k2]
   759108       jac_step_ij[7+k1,k2]=jac_step[indj+k1,k2]
        -     end
        -     jac_step_ij .= *(jac_ij,jac_step_ij)
    27111     for k2=1:7*n, k1=1:7
    27111       jac_step[indi+k1,k2]=jac_step_ij[  k1,k2]
        0       jac_step[indj+k1,k2]=jac_step_ij[7+k1,k2]
        0     end
        -     driftij!(x,v,i,j,-h2,jac_step,n) 
    27111   end
        - end
        - drift!(x,v,h2,n,jac_step)
        - if alpha != 0.0
        -   phisalpha!(x,v,h,m,alpha,n,jac_phi)
        -   jac_step .= jac_phi*jac_step # < 1%
        - end
        - return
        - end
        - 
        - function findtransit!(i,h,g1,g2,m,x1,v1,x2,v2)
        - # Computes the transit time, approximating the motion
        - # as a Keplerian forward & backward in time, weighted by location in the timestep.
        - # Initial guess using linear interpolation:
        - tt = -g1*h/(g2-g1)
        - dt = 1.0
        - 
        - # Setup state vectors for kepler_step:
        - s10 = zeros(Float64,12)
        - s20 = zeros(Float64,12)
        - # Final state (after a step):
        - s1 = zeros(Float64,12)
        - s2 = zeros(Float64,12)
        - s = zeros(Float64,12)
        - for k=1:NDIM
        -   s10[1+k     ] = x1[k,i] - x1[k,1]
        -   s10[1+k+NDIM] = v1[k,i] - v1[k,1]
        -   s20[1+k     ] = x2[k,i] - x2[k,1]
        -   s20[1+k+NDIM] = v2[k,i] - v2[k,1]
        - end
        - gm = GNEWT*(m[i]+m[1])
        - iter = 0
        - accel1= 0.
        - accel2= 0.
        - accel = zeros(Float64,3)
        - while abs(dt) > 1e-8 && iter < 20
        -   # Advance planet state at start of step to estimated transit time:
        -   kepler_step!(gm,    tt, s10, s1)
        -   # Reverse planet state at end of step to estimated transit time:
        -   kepler_step!(gm, -h+tt, s20, s2)
        -   # Weight:
        -   w = tt/h
        -   # Compute weighting of states:
        -   for j=2:7
        -     s[j] = (1.0-w)*s1[j]+w*s2[j]
        -   end
        -   # Compute time offset:
        -   g = s[2]*s[5]+s[3]*s[6]
        -   # Compute gravitational acceleration
        -   r1_3 = norm(s1[2:4])^3
        -   r2_3 = norm(s2[2:4])^3
        -   for k=1:3
        -     accel1 = -gm*s1[k+1]/r1_3
        -     accel2 = -gm*s2[k+1]/r2_3
        -     accel[k] = accel1*(1.0-w)+accel2*w
        -   end
        -   # Compute derivative of g with respect to time:
        -   gdot = s[5]^2+s[6]^2+s[2]*accel[1]+s[3]*accel[2]
        -   # Include time derivatives of interpolation (10/4/17 notes):
        -   gdot += ((s2[2]-s1[2])*s[5] + (s2[5]-s1[5])*s[2] +(s2[3]-s1[3])*s[6]+(s2[6]-s1[6])*s[3])/h
        -   # Refine estimate of transit time with Newton's method:
        -   dt = -g/gdot
        -   # Add refinement to estimated time:
        -   tt += dt
        -   iter +=1
        - end
        - # Note: this is the time elapsed *after* the beginning of the timestep:
        - return tt
        - end
        - 
        - function findtransit!(i,h,g1,g2,m,x1,v1,x2,v2,dtdqn)
        - # Computes the transit time, approximating the motion
        - # as a Keplerian forward & backward in time, weighted by location in the timestep.
        - # Initial guess using linear interpolation:
        - tt = -g1*h/(g2-g1)
        - dt = 1.0
        - 
        - # Vector for computing derivative with respect to the initial and final elements
        - # of the planet & star -  2 planets with 7 elements/masses at two times (initial & final):
        - dtdqn = zeros(7,2,2)
        - 
        - # Setup state vectors for kepler_step:
        - s10 = zeros(Float64,12)
        - s20 = zeros(Float64,12)
        - # Final state (after a step):
        - s1 = zeros(Float64,12)
        - s2 = zeros(Float64,12)
        - s = zeros(Float64,12)
        - for k=1:NDIM
        -   s10[1+k     ] = x1[k,i] - x1[k,1]
        -   s10[1+k+NDIM] = v1[k,i] - v1[k,1]
        -   s20[1+k     ] = x2[k,i] - x2[k,1]
        -   s20[1+k+NDIM] = v2[k,i] - v2[k,1]
        - end
        - gm = GNEWT*(m[i]+m[1])
        - iter = 0
        - accel1= 0.
        - accel2= 0.
        - accel = zeros(Float64,3)
        - while abs(dt) > 1e-8 && iter < 20
        -   # Advance planet state at start of step to estimated transit time:
        -   kepler_step!(gm,    tt, s10, s1)
        -   # Reverse planet state at end of step to estimated transit time:
        -   kepler_step!(gm, -h+tt, s20, s2)
        -   # Weight:
        -   w = tt/h
        -   # Compute weighting of states:
        -   for j=2:7
        -     s[j] = (1.0-w)*s1[j]+w*s2[j]
        -   end
        -   # Compute time offset:
        -   g = s[2]*s[5]+s[3]*s[6]
        -   # Compute gravitational acceleration
        -   r1_3 = norm(s1[2:4])^3
        -   r2_3 = norm(s2[2:4])^3
        -   for k=1:3
        -     accel1 = -gm*s1[k+1]/r1_3
        -     accel2 = -gm*s2[k+1]/r2_3
        -     accel[k] = accel1*(1.0-w)+accel2*w
        -   end
        -   # Compute derivative of g with respect to time:
        -   gdot = s[5]^2+s[6]^2+s[2]*accel[1]+s[3]*accel[2]
        -   # Include time derivatives of interpolation (10/4/17 notes):
        -   gdot += ((s2[2]-s1[2])*s[5] + (s2[5]-s1[5])*s[2] +(s2[3]-s1[3])*s[6]+(s2[6]-s1[6])*s[3])/h
        -   # Refine estimate of transit time with Newton's method:
        -   dt = -g/gdot
        -   # Add refinement to estimated time:
        -   tt += dt
        -   iter +=1
        - end
        - # Now compute derivative of transit time with respect to initial (& final)
        - # positions & masses of the planet/star:
        - 
        - 
     3108 # Note: this is the time elapsed *after* the beginning of the timestep:
     3108 return tt
     3108 end
     3108 
     3108 function findtransit2!(i::Int64,j::Int64,h::Float64,tt::Float64,m::Array{Float64,1},x1::Array{Float64,2},v1::Array{Float64,2})
     3108 # Computes the transit time, approximating the motion as a fraction of a DH17 step forward in time.
     3108 # Initial guess using linear interpolation:
     6067 dt = 1.0
     6067 iter = 0
        - r3 = 0.0
     6067 gdot = 0.0
        - x = copy(x1)
     6067 v = copy(v1)
        - while abs(dt) > 1e-8 && iter < 20
     6067   x .= x1
     6067   v .= v1
    48536   # Advance planet state at start of step to estimated transit time:
    42469   dh17!(x,v,tt,m,n)
    42469   # Compute time offset:
        -   gsky = g!(i,j,x,v)
    48536   # Compute gravitational acceleration in sky plane dotted with sky position:
    42469   gdot = 0.0
    42469   for k=1:n
        -     if k != i
        -       r3 = sqrt((x[1,k]-x[1,i])^2+(x[2,k]-x[2,i])^2 +(x[3,k]-x[3,i])^2)^3
        -       gdot += GNEWT*m[k]*((x[1,k]-x[1,i])*(x[1,j]-x[1,i])+(x[2,k]-x[2,i])*(x[2,j]-x[2,i]))/r3
     6067     end
        -     if k != j
     6067       r3 = sqrt((x[1,k]-x[1,j])^2+(x[2,k]-x[2,j])^2 +(x[3,k]-x[3,j])^2)^3
        -       gdot -= GNEWT*m[k]*((x[1,k]-x[1,j])*(x[1,j]-x[1,i])+(x[2,k]-x[2,j])*(x[2,j]-x[2,i]))/r3
     6067     end
     6067   end
        -   # Compute derivative of g with respect to time:
        -   gdot += (v[1,j]-v[1,i])^2+(v[2,j]-v[2,i])^2
        -   # Refine estimate of transit time with Newton's method:
        -   dt = -gsky/gdot
     3108   # Add refinement to estimated time:
        -   tt += dt
        -   iter +=1
        - end
        - # Compute derivatives:
        - #  dh17!(x,v,tt,m,n,jac_step)
        - # Note: this is the time elapsed *after* the beginning of the timestep:
     3108 return tt::Float64
     3108 end
     3108 
     3108 function findtransit2!(i::Int64,j::Int64,h::Float64,tt::Float64,m::Array{Float64,1},x1::Array{Float64,2},v1::Array{Float64,2},jac_step::Array{Float64,2},dtdq::Array{Float64,2})
     3108 # Computes the transit time, approximating the motion as a fraction of a DH17 step forward in time.
     3108 # Also computes the Jacobian of the transit time with respect to the initial parameters, dtdq[7,n].
     3108 # Initial guess using linear interpolation:
     6216 dt = 1.0
     6216 iter = 0
        - r3 = 0.0
     6216 gdot = 0.0
        - x = copy(x1)
     6216 v = copy(v1)
        - while abs(dt) > 1e-8 && iter < 20
     6216   x .= x1
     6216   v .= v1
    49728   # Advance planet state at start of step to estimated transit time:
    43512   dh17!(x,v,tt,m,n)
    43512   # Compute time offset:
        -   gsky = g!(i,j,x,v)
    49728   # Compute gravitational acceleration in sky plane dotted with sky position:
    43512   gdot = 0.0
    43512   for k=1:n
        -     if k != i
        -       r3 = sqrt((x[1,k]-x[1,i])^2+(x[2,k]-x[2,i])^2 +(x[3,k]-x[3,i])^2)^3
        -       gdot += GNEWT*m[k]*((x[1,k]-x[1,i])*(x[1,j]-x[1,i])+(x[2,k]-x[2,i])*(x[2,j]-x[2,i]))/r3
     6216     end
        -     if k != j
     6216       r3 = sqrt((x[1,k]-x[1,j])^2+(x[2,k]-x[2,j])^2 +(x[3,k]-x[3,j])^2)^3
        -       gdot -= GNEWT*m[k]*((x[1,k]-x[1,j])*(x[1,j]-x[1,i])+(x[2,k]-x[2,j])*(x[2,j]-x[2,i]))/r3
     6216     end
     6216   end
        -   # Compute derivative of g with respect to time:
        -   gdot += (v[1,j]-v[1,i])^2+(v[2,j]-v[2,i])^2
     3108   # Refine estimate of transit time with Newton's method:
     3108   dt = -gsky/gdot
        -   # Add refinement to estimated time:
     3108   tt += dt
        -   iter +=1
     3108 end
        - # Compute time derivatives:
     3108 x = copy(x1)
     3108 v = copy(v1)
    24864 # Compute dgdt with the updated time step.
    21756 dh17!(x,v,tt,m,n,jac_step)
    21756 # Compute time offset:
        - gsky = g!(i,j,x,v)
    24864 # Compute gravitational acceleration in sky plane dotted with sky position:
    21756 gdot = 0.0
    21756 for k=1:n
        -   if k != i
        -     r3 = sqrt((x[1,k]-x[1,i])^2+(x[2,k]-x[2,i])^2 +(x[3,k]-x[3,i])^2)^3
        -     gdot += GNEWT*m[k]*((x[1,k]-x[1,i])*(x[1,j]-x[1,i])+(x[2,k]-x[2,i])*(x[2,j]-x[2,i]))/r3
     3108   end
        -   if k != j
     3108     r3 = sqrt((x[1,k]-x[1,j])^2+(x[2,k]-x[2,j])^2 +(x[3,k]-x[3,j])^2)^3
     3108     gdot -= GNEWT*m[k]*((x[1,k]-x[1,j])*(x[1,j]-x[1,i])+(x[2,k]-x[2,j])*(x[2,j]-x[2,i]))/r3
    21756   end
        - end
   174048 # Compute derivative of g with respect to time:
   174048 gdot += (v[1,j]-v[1,i])^2+(v[2,j]-v[2,i])^2
   174048 # Set dtdq to zero:
   174048 fill!(dtdq,0.0)
        - for k=1:7
        -   for p=1:n
        -     # Compute derivatives:
        -     indj = (j-1)*7+1
     3108     indi = (i-1)*7+1
        -     indp = (p-1)*7
        -     dtdq[k,p] = -((jac_step[indj,indp+k]-jac_step[indi,indp+k])*(v[1,j]-v[1,i])+(jac_step[indj+1,indp+k]-jac_step[indi+1,indp+k])*(v[2,j]-v[2,i])+
        -                   (jac_step[indj+3,indp+k]-jac_step[indi+3,indp+k])*(x[1,j]-x[1,i])+(jac_step[indj+4,indp+k]-jac_step[indi+4,indp+k])*(x[2,j]-x[2,i]))/gdot
        -   end
        - end
        - # Note: this is the time elapsed *after* the beginning of the timestep:
        - return tt::Float64
        - end
        - 
