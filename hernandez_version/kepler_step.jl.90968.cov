        - include("kepler_solver_derivative.jl")
        - 
        - # Takes a single kepler step, calling Wisdom & Hernandez solver
        - # 
        - function kepler_step!(gm::Float64,h::Float64,state0::Array{Float64,1},state::Array{Float64,1})
        - # compute beta, r0, dr0dt, get x/v from state vector & call correct subroutine
  6064016 x0 = zeros(Float64,3)
  6064016 v0 = zeros(Float64,3)
  6064016 for k=1:3
 18192048   x0[k]=state0[k+1]
 18192048   v0[k]=state0[k+4]
        - end
        - #  x0=state0[2:4]
  6064016   r0 = sqrt(x0[1]*x0[1]+x0[2]*x0[2]+x0[3]*x0[3])
        - #  v0 = state0[5:7]
  6064016   dr0dt = (x0[1]*v0[1]+x0[2]*v0[2]+x0[3]*v0[3])/r0
  6064016   beta0 = 2.0*gm/r0-(v0[1]*v0[1]+v0[2]*v0[2]+v0[3]*v0[3])
  6064016   s0=state0[11]
  6064016   if beta0 > 0.0
  1516004     iter = kep_elliptic!(x0,v0,r0,dr0dt,gm,h,beta0,s0,state)
        -   else
  4548012     iter = kep_hyperbolic!(x0,v0,r0,dr0dt,gm,h,beta0,s0,state)
        -   end
  6064016 return
        - end
        - 
        - function kepler_step!(gm::Float64,h::Float64,state0::Array{Float64,1},state::Array{Float64,1},jacobian::Array{Float64,2})
        - # compute beta, r0, dr0dt, get x/v from state vector & call correct subroutine
  1518216 x0 = zeros(Float64,3)
  1518216 v0 = zeros(Float64,3)
  1518216 for k=1:3
  4554648   x0[k]=state0[k+1]
  4554648   v0[k]=state0[k+4]
        - end
        - #  x0=state0[2:4]
  1518216   r0 = sqrt(x0[1]*x0[1]+x0[2]*x0[2]+x0[3]*x0[3])
        - #  v0 = state0[5:7]
  1518216   dr0dt = (x0[1]*v0[1]+x0[2]*v0[2]+x0[3]*v0[3])/r0
  1518216   beta0 = 2.0*gm/r0-(v0[1]*v0[1]+v0[2]*v0[2]+v0[3]*v0[3])
  1518216   s0=state0[11]
  1518216   if beta0 > 0.0
   379554     iter = kep_elliptic!(x0,v0,r0,dr0dt,gm,h,beta0,s0,state,jacobian)
        -   else
  1138662     iter = kep_hyperbolic!(x0,v0,r0,dr0dt,gm,h,beta0,s0,state,jacobian)
        -   end
  1518216 return
        - end
        - 
