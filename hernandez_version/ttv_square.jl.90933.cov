        - # Translation of David Hernandez's nbody.c for integrating hiercharical
        - # system with BH15 integrator.  Please cite Hernandez & Bertschinger (2015)
        - # if using this in a paper.
        - 
        - const YEAR  = 365.242
        - const GNEWT = 39.4845/YEAR^2
        - const NDIM  = 3
        - const KEPLER_TOL = 1e-8
        - const third = 1./3.
        - const alpha0 = 0.0
        - include("kepler_step.jl")
        - include("init_nbody.jl")
        - const pxpr0 = zeros(Float64,3);const  pxpa0=zeros(Float64,3);const  pxpk=zeros(Float64,3);const  pxps=zeros(Float64,3);const  pxpbeta=zeros(Float64,3)
        - const dxdr0 = zeros(Float64,3);const  dxda0=zeros(Float64,3);const  dxdk=zeros(Float64,3);const  dxdv0 =zeros(Float64,3)
        - const prvpr0 = zeros(Float64,3);const  prvpa0=zeros(Float64,3);const  prvpk=zeros(Float64,3);const  prvps=zeros(Float64,3);const  prvpbeta=zeros(Float64,3)
        - const drvdr0 = zeros(Float64,3);const  drvda0=zeros(Float64,3);const  drvdk=zeros(Float64,3);const  drvdv0=zeros(Float64,3)
        - const vtmp = zeros(Float64,3);const  dvdr0 = zeros(Float64,3);const  dvda0=zeros(Float64,3);const  dvdv0=zeros(Float64,3);const  dvdk=zeros(Float64,3)
        - 
        - const state0 = zeros(Float64,12); state = zeros(Float64,12); delx = zeros(Float64,NDIM); delv = zeros(Float64,NDIM); xcm = zeros(Float64,NDIM); vcm = zeros(Float64,NDIM)
        - 
        - function ttv!(n::Int64,t0::Float64,h::Float64,tmax::Float64,elements::Array{Float64,2},tt::Array{Float64,2},count::Array{Int64,1},dtdq0::Array{Float64,4})
        - #fcons = open("fcons.txt","w");
        1 m=zeros(Float64,n)
        1 x=zeros(Float64,NDIM,n)
        1 v=zeros(Float64,NDIM,n)
        - # Fill the transit-timing & jacobian arrays with zeros:
        1 fill!(tt,0.0)
        1 fill!(dtdq0,0.0)
        - # Counter for transits of each planet:
        1 fill!(count,0)
        1 for i=1:n
        8   m[i] = elements[i,1]
        - end
        - # Initialize the N-body problem using nested hierarchy of Keplerians:
        1 x,v = init_nbody(elements,t0,n)
        1 xprior = copy(x)
        1 vprior = copy(v)
        - # Set the time to the initial time:
        1 t = t0
        - # Set step counter to zero:
        1 istep = 0
        - # Jacobian for each step (7- 6 elements+mass, n_planets, 7 - 6 elements+mass, n planets):
        - #jac_step = zeros(Float64,7*n,7*n)
        1 jac_prior = zeros(Float64,7*n,7*n)
        1 dtdq = zeros(Float64,7,n)
        - # Initialize the Jacobian to the identity matrix:
        1 jac_step = eye(Float64,7*n)
        - 
        - # Save the g function, which computes the relative sky velocity dotted with relative position
        - # between the planets and star:
        1 gsave = zeros(Float64,n)
        - # Loop over time steps:
        1 dt::Float64 = 0.0
        1 gi = 0.0
        1 while t < t0+tmax
        -   # Carry out a phi^2 mapping step:
        - #  phi2!(x,v,h,m,n)
     6916   dh17!(x,v,h,m,n,jac_step)
        -   # Check to see if a transit may have occured.  Sky is x-y plane; line of sight is z.
        -   # Star is body 1; planets are 2-nbody (note that this could be modified to see if
        -   # any body transits another body):
     6915   for i=2:n
        -     # Compute the relative sky velocity dotted with position:
    48405     gi = g!(i,1,x,v)
    48405     ri = sqrt(x[1,i]^2+x[2,i]^2+x[3,i]^2)
        -     # See if sign switches, and if planet is in front of star (by a good amount):
    48405     if gi > 0 && gsave[i] < 0 && x[3,i] > 0.25*ri
        -       # A transit has occurred between the time steps.
        -       # Approximate the planet-star motion as a Keplerian, weighting over timestep:
      895       count[i] += 1
        - #      tt[i,count[i]]=t+findtransit!(i,h,gi,gsave[i],m,xprior,vprior,x,v)
      895       dt = -gsave[i]*h/(gi-gsave[i])
        - #      dt = findtransit2!(1,i,h,dt,m,xprior,vprior)
      895       xtransit = copy(xprior)
      895       vtransit = copy(vprior)
      895       jac_transit = copy(jac_prior)
      895       dt = findtransit2!(1,i,h,dt,m,xtransit,vtransit,jac_transit,dtdq) # 20%
      895       tt[i,count[i]]=t+dt
        -       # Save for posterity:
      895       for k=1:7, p=1:n
    50120         dtdq0[i,count[i],k,p] = dtdq[k,p]
        -       end
        -     end
    48405     gsave[i] = gi
        -   end
        -   # Save the current state as prior state:
     6915   xprior = copy(x)
     6915   vprior = copy(v)
     6915   jac_prior = copy(jac_step)
        -   # Increment time by the time step:
     6915   t += h
        -   # Increment counter by one:
     6915   istep +=1
        - end
        0 return 
        - end
        - 
        - function ttv!(n::Int64,t0::Float64,h::Float64,tmax::Float64,elements::Array{Float64,2},tt::Array{Float64,2},count::Array{Int64,1},dlnq::Float64,iq::Int64,jq::Int64)
        - #fcons = open("fcons.txt","w");
        3 m=zeros(Float64,n)
        3 x=zeros(Float64,NDIM,n)
        3 v=zeros(Float64,NDIM,n)
        - # Fill the transit-timing array with zeros:
        3 fill!(tt,0.0)
        - # Counter for transits of each planet:
        3 fill!(count,0)
        3 for i=1:n
       24   m[i] = elements[i,1]
        - end
        - # Allow for perturbations to initial conditions: jq labels body; iq labels phase-space element (or mass)
        - # iq labels phase-space element (1-3: x; 4-6: v; 7: m)
        3 dq = 0.0
        3 if iq == 7 && dlnq != 0.0
        0   dq = m[jq]*dlnq
        0   m[jq] += dq
        - end
        - # Initialize the N-body problem using nested hierarchy of Keplerians:
        3 x,v = init_nbody(elements,t0,n)
        - # Perturb the initial condition by an amount dlnq (if it is non-zero):
        3 if dlnq != 0.0 && iq > 0 && iq < 7
        0   if iq < 4
        0     if x[iq,jq] != 0
        0       dq = x[iq,jq]*dlnq
        -     else
        0       dq = dlnq
        -     end
        0     x[iq,jq] += dq
        -   else
        -   # Same for v
        0     if v[iq-3,jq] != 0
        0       dq = v[iq-3,jq]*dlnq
        -     else
        0       dq = dlnq
        -     end
        0     v[iq-3,jq] += dq
        -   end
        - end
        3 xprior = copy(x)
        3 vprior = copy(v)
        - # Set the time to the initial time:
        3 t = t0
        - # Set step counter to zero:
        3 istep = 0
        - # Jacobian for each step (7 elements+mass, n_planets, 7 elements+mass, n planets):
        - # Save the g function, which computes the relative sky velocity dotted with relative position
        - # between the planets and star:
        3 gsave = zeros(Float64,n)
        3 gi  = 0.0
        3 dt::Float64 = 0.0
        - # Loop over time steps:
        3 while t < t0+tmax
        -   # Carry out a phi^2 mapping step:
        - #  phi2!(x,v,h,m,n)
    96003   dh17!(x,v,h,m,n)
        -   # Check to see if a transit may have occured.  Sky is x-y plane; line of sight is z.
        -   # Star is body 1; planets are 2-nbody:
    96003   for i=2:n
        -     # Compute the relative sky velocity dotted with position:
   672021     gi = g!(i,1,x,v)
   672021     ri = sqrt(x[1,i]^2+x[2,i]^2+x[3,i]^2)
        -     # See if sign switches, and if planet is in front of star (by a good amount):
   672021     if gi > 0 && gsave[i] < 0 && x[3,i] > 0.25*ri
        -       # A transit has occurred between the time steps.
        -       # Approximate the planet-star motion as a Keplerian, weighting over timestep:
     3108       count[i] += 1
        - #      tt[i,count[i]]=t+findtransit!(i,h,gi,gsave[i],m,xprior,vprior,x,v)
     3108       dt = -gsave[i]*h/(gi-gsave[i])
     3108       xtransit = copy(xprior)
     3108       vtransit = copy(vprior)
     3108       dt = findtransit2!(1,i,h,dt,m,xtransit,vtransit)
     3108       tt[i,count[i]]=t+dt
        - #      tt[i,count[i]]=t+findtransit2!(1,i,h,gi,gsave[i],m,xprior,vprior)
        -     end
   672021     gsave[i] = gi
        -   end
        -   # Save the current state as prior state:
    96003   xprior .=x
    96003   vprior .=v
        -   # Increment time by the time step:
    96003   t += h
        -   # Increment counter by one:
    96003   istep +=1
        - end
        3 return dq
        - end
        - 
        - # Advances the center of mass of a binary
        - function centerm!(m::Array{Float64,1},mijinv::Float64,x::Array{Float64,2},v::Array{Float64,2},vcm::Array{Float64,1},delx::Array{Float64,1},delv::Array{Float64,1},i::Int64,j::Int64,h::Float64)
  6253546 for k=1:NDIM
 18760638   x[k,i] +=  m[j]*mijinv*delx[k] + h*vcm[k]
 18760638   x[k,j] += -m[i]*mijinv*delx[k] + h*vcm[k]
 18760638   v[k,i] +=  m[j]*mijinv*delv[k]
 18760638   v[k,j] += -m[i]*mijinv*delv[k]
        - end
  6253546 return
        - end
        - 
        - 
        - # Drifts bodies i & j
        - function driftij!(x::Array{Float64,2},v::Array{Float64,2},i::Int64,j::Int64,h::Float64)
  5816160 for k=1:NDIM
 17448480   x[k,i] += h*v[k,i]
 17448480   x[k,j] += h*v[k,j]
        - end
  5816160 return
        - end
        - 
        - # Drifts bodies i & j
        - function driftij!(x::Array{Float64,2},v::Array{Float64,2},i::Int64,j::Int64,h::Float64,jac_step::Array{Float64,2},nbody::Int64)
   437387 indi = (i-1)*7
   437387 indj = (j-1)*7
   437387 for k=1:NDIM
  1312161   x[k,i] += h*v[k,i]
  1312161   x[k,j] += h*v[k,j]
        -   # Now for Jacobian:
  1312161   for m=1:7*nbody
 73481016     jac_step[indi+k,m] += h*jac_step[indi+3+k,m]
 73481016     jac_step[indj+k,m] += h*jac_step[indj+3+k,m]
        -   end    
        - end
   437387 return
        - end
        - 
        - # Carries out a Kepler step for bodies i & j
        - function keplerij!(m::Array{Float64,1},x::Array{Float64,2},v::Array{Float64,2},i::Int64,j::Int64,h::Float64)
        - # The state vector has: 1 time; 2-4 position; 5-7 velocity; 8 r0; 9 dr0dt; 10 beta; 11 s; 12 ds
        - # Initial state:
  5816160 state0 = zeros(Float64,12)
        - # Final state (after a step):
  5816160 state = zeros(Float64,12)
  5816160 delx = zeros(Float64,NDIM)
  5816160 delv = zeros(Float64,NDIM)
        - #println("Masses: ",i," ",j)
  5816160 for k=1:NDIM
 17448480   state0[1+k     ] = x[k,i] - x[k,j]
 17448480   state0[1+k+NDIM] = v[k,i] - v[k,j]
        - end
  5816160 gm = GNEWT*(m[i]+m[j])
  5816160 if gm == 0
        0   for k=1:NDIM
        0     x[k,i] += h*v[k,i]
        0     x[k,j] += h*v[k,j]
        -   end
        - else
        -   # predicted value of s
  5816160   state0[11]=0.0
  5816160   kepler_step!(gm, h, state0, state)
  5816160   for k=1:NDIM
 17448480     delx[k] = state[1+k] - state0[1+k]
 17448480     delv[k] = state[1+NDIM+k] - state0[1+NDIM+k]
        -   end
        - # Advance center of mass:
        - # Compute COM coords:
  5816160   mijinv =1.0/(m[i] + m[j])
  5816160   vcm = zeros(Float64,NDIM)
  5816160   for k=1:NDIM
 17448480     vcm[k] = (m[i]*v[k,i] + m[j]*v[k,j])*mijinv
        -   end
  5816160   centerm!(m,mijinv,x,v,vcm,delx,delv,i,j,h)
        - end
  5816160 return
        - end
        - 
        - # Carries out a Kepler step for bodies i & j
        - function keplerij!(m::Array{Float64,1},x::Array{Float64,2},v::Array{Float64,2},i::Int64,j::Int64,h::Float64,jac_ij::Array{Float64,2})
        - # The state vector has: 1 time; 2-4 position; 5-7 velocity; 8 r0; 9 dr0dt; 10 beta; 11 s; 12 ds
        - # Initial state:
   437387 state0 = zeros(Float64,12)
        - # Final state (after a step):
   437386 state = zeros(Float64,12)
   437386 delx = zeros(Float64,NDIM)
   437386 delv = zeros(Float64,NDIM)
        - # jac_ij should be the Jacobian for going from (x_{0,i},v_{0,i},m_i) &  (x_{0,j},v_{0,j},m_j)
        - # to  (x_i,v_i,m_i) &  (x_j,v_j,m_j), a 14x14 matrix for the 3-dimensional case. 
        - # Fill with zeros for now:
   437386 fill!(jac_ij,0.0)
   437386 for k=1:NDIM
  1312158   state0[1+k     ] = x[k,i] - x[k,j]
  1312158   state0[1+k+NDIM] = v[k,i] - v[k,j]
        - end
   437386 gm = GNEWT*(m[i]+m[j])
        - # The following jacobian is just computed for the Keplerian coordinates (i.e. doesn't include
        - # center-of-mass motion, or scale to motion of bodies about their common center of mass):
   437386 jac_kepler = zeros(Float64,7,7)
   437386 kepler_step!(gm, h, state0, state, jac_kepler)
   437386 for k=1:NDIM
  1312158   delx[k] = state[1+k] - state0[1+k]
  1312158   delv[k] = state[1+NDIM+k] - state0[1+NDIM+k]
        - end
        - # Compute COM coords:
   437386 mijinv =1.0/(m[i] + m[j])
   437386 xcm = zeros(Float64,NDIM)
   437386 vcm = zeros(Float64,NDIM)
   437386 mi = m[i]*mijinv # Normalize the masses
   437386 mj = m[j]*mijinv
        - #println("Masses: ",i," ",j)
   437386 for k=1:NDIM
  1312158   xcm[k] = mi*x[k,i] + mj*x[k,j]
  1312158   vcm[k] = mi*v[k,i] + mj*v[k,j]
        - end
        - # Compute the Jacobian:
   437386 jac_ij[ 7, 7] = 1.0  # the masses don't change with time!
   437386 jac_ij[14,14] = 1.0
   437386 for k=1:NDIM
  1312158    jac_ij[   k,   k] +=   mi
  1312158    jac_ij[   k, 3+k] += h*mi
  1312158    jac_ij[   k, 7+k] +=   mj
  1312158    jac_ij[   k,10+k] += h*mj
  1312158    jac_ij[ 3+k, 3+k] +=   mi
  1312158    jac_ij[ 3+k,10+k] +=   mj
  1312158    jac_ij[ 7+k,   k] +=   mi
  1312158    jac_ij[ 7+k, 3+k] += h*mi
  1312158    jac_ij[ 7+k, 7+k] +=   mj
  1312158    jac_ij[ 7+k,10+k] += h*mj
  1312158    jac_ij[10+k, 3+k] +=   mi
  1312158    jac_ij[10+k,10+k] +=   mj
  1312158    for l=1:NDIM
        - # Compute derivatives of \delta x_i with respect to initial conditions:
  3936474      jac_ij[   k,   l] += mj*jac_kepler[  k,  l]
  3936474      jac_ij[   k, 3+l] += mj*jac_kepler[  k,3+l]
  3936474      jac_ij[   k, 7+l] -= mj*jac_kepler[  k,  l]
  3936474      jac_ij[   k,10+l] -= mj*jac_kepler[  k,3+l]
        - # Compute derivatives of \delta v_i with respect to initial conditions:
  3936474      jac_ij[ 3+k,   l] += mj*jac_kepler[3+k,  l]
  3936474      jac_ij[ 3+k, 3+l] += mj*jac_kepler[3+k,3+l]
  3936474      jac_ij[ 3+k, 7+l] -= mj*jac_kepler[3+k,  l]
  3936474      jac_ij[ 3+k,10+l] -= mj*jac_kepler[3+k,3+l]
        - # Compute derivatives of \delta x_j with respect to initial conditions:
  3936474      jac_ij[ 7+k,   l] -= mi*jac_kepler[  k,  l]
  3936474      jac_ij[ 7+k, 3+l] -= mi*jac_kepler[  k,3+l]
  3936474      jac_ij[ 7+k, 7+l] += mi*jac_kepler[  k,  l]
  3936474      jac_ij[ 7+k,10+l] += mi*jac_kepler[  k,3+l]
        - # Compute derivatives of \delta v_j with respect to initial conditions:
  3936474      jac_ij[10+k,   l] -= mi*jac_kepler[3+k,  l]
  3936474      jac_ij[10+k, 3+l] -= mi*jac_kepler[3+k,3+l]
  3936474      jac_ij[10+k, 7+l] += mi*jac_kepler[3+k,  l]
  3936474      jac_ij[10+k,10+l] += mi*jac_kepler[3+k,3+l]
        -    end
        - # Compute derivatives of \delta x_i with respect to the masses:
  1312158    jac_ij[   k, 7] += (x[k,i]+h*v[k,i]-xcm[k]-h*vcm[k]-mj*state[1+k])*mijinv + GNEWT*mj*jac_kepler[  k,7]
  1312158    jac_ij[   k,14] += (x[k,j]+h*v[k,j]-xcm[k]-h*vcm[k]+mi*state[1+k])*mijinv + GNEWT*mj*jac_kepler[  k,7]
        - # Compute derivatives of \delta v_i with respect to the masses:
  1312158    jac_ij[ 3+k, 7] += (v[k,i]-vcm[k]-mj*state[4+k])*mijinv + GNEWT*mj*jac_kepler[3+k,7]
  1312158    jac_ij[ 3+k,14] += (v[k,j]-vcm[k]+mi*state[4+k])*mijinv + GNEWT*mj*jac_kepler[3+k,7]
        - # Compute derivatives of \delta x_j with respect to the masses:
  1312158    jac_ij[ 7+k, 7] += (x[k,i]+h*v[k,i]-xcm[k]-h*vcm[k]-mj*state[1+k])*mijinv - GNEWT*mi*jac_kepler[  k,7]
  1312158    jac_ij[ 7+k,14] += (x[k,j]+h*v[k,j]-xcm[k]-h*vcm[k]+mi*state[1+k])*mijinv - GNEWT*mi*jac_kepler[  k,7]
        - # Compute derivatives of \delta v_j with respect to the masses:
  1312158    jac_ij[10+k, 7] += (v[k,i]-vcm[k]-mj*state[4+k])*mijinv - GNEWT*mi*jac_kepler[3+k,7]
  1312158    jac_ij[10+k,14] += (v[k,j]-vcm[k]+mi*state[4+k])*mijinv - GNEWT*mi*jac_kepler[3+k,7]
        - end
        - # Advance center of mass & individual Keplerian motions:
   437386 centerm!(m,mijinv,x,v,vcm,delx,delv,i,j,h)
   437386 return
        - end
        - 
        - # Drifts all particles:
        - function drift!(x::Array{Float64,2},v::Array{Float64,2},h::Float64,n::Int64)
   207720 for i=1:n, j=1:NDIM
  4985280   x[j,i] += h*v[j,i]
        - end
   207720 return
        - end
        - 
        - # Drifts all particles:
        - function drift!(x::Array{Float64,2},v::Array{Float64,2},h::Float64,n::Int64,jac_step::Array{Float64,2})
    15621 indi = 0
    15621 for i=1:n
   124968   indi = (i-1)*7
   124968   for j=1:NDIM
   374904     x[j,i] += h*v[j,i]
        -     # Now for Jacobian:
   374904     for k=1:7*n
 20994624       jac_step[indi+j,k] += h*jac_step[indi+3+j,k]
        -     end    
        -   end
        - end
    15621 return
        - end
        - 
        - function phisalpha!(x::Array{Float64,2},v::Array{Float64,2},h::Float64,m::Array{Float64,1},alpha::Float64,n::Int64)
        - # Computes the 4th-order correction:
        - #function [v] = phisalpha(x,v,h,m,alpha)
        - #n = size(m,2);
   103860 a = zeros(Float64,3,n)
   103860 rij = zeros(Float64,3)
   103860 aij = zeros(Float64,3)
   103860 coeff = alpha*h^3/96*2*GNEWT
   623160 fac = 0.0; fac1 = 0.0; fac2 = 0.0; r1 = 0.0; r2 = 0.0; r3 = 0.0
   103860 for i=1:n
   830880   for j = i+1:n
  2908080     for k=1:3
  8724240       rij[k] = x[k,i] - x[k,j]
        -     end
  2908080     r2 = rij[1]*rij[1]+rij[2]*rij[2]+rij[3]*rij[3]
  2908080     r3 = r2*sqrt(r2)
  2908080     for k=1:3
  8724240       fac = GNEWT*rij[k]/r3
  8724240       a[k,i] -= m[j]*fac
  8724240       a[k,j] += m[i]*fac
        -     end
        -   end
        - end
        - # Next, compute \tilde g_i acceleration vector (this is rewritten
        - # slightly to avoid reference to \tilde a_i):
   103860 for i=1:n
   830880   for j=i+1:n
  2908080     for k=1:3
  8724240       aij[k] = a[k,i] - a[k,j]
        - #      aij[k] = 0.0
  8724240       rij[k] = x[k,i] - x[k,j]
        -     end
  2908080     r2 = rij[1]*rij[1]+rij[2]*rij[2]+rij[3]*rij[3]
  2908080     r1 = sqrt(r2)
  2908080     ardot = aij[1]*rij[1]+aij[2]*rij[2]+aij[3]*rij[3]
  2908080     fac1 = coeff/r1^5
  2908080     fac2 = (2*GNEWT*(m[i]+m[j])/r1 + 3*ardot) 
  2908080     for k=1:3
        - #      fac = coeff/r1^5*(rij[k]*(2*GNEWT*(m[i]+m[j])/r1 + 3*ardot) - r2*aij[k])
  8724240       fac = fac1*(rij[k]*fac2- r2*aij[k])
  8724240       v[k,i] += m[j]*fac
  8724240       v[k,j] -= m[i]*fac
        -     end
        -   end
        - end
   103860 return
        - end
        - 
        - function phisalpha!(x::Array{Float64,2},v::Array{Float64,2},h::Float64,m::Array{Float64,1},alpha::Float64,n::Int64,jac_step::Array{Float64,2})
        - # Computes the 4th-order correction:
        - #function [v] = phisalpha(x,v,h,m,alpha)
        - #n = size(m,2);
     7810 a = zeros(Float64,3,n)
     7810 dadq = zeros(Float64,3,n,4,n)  # There is no velocity dependence
     7810 dotdadq = zeros(Float64,4,n)  # There is no velocity dependence
     7810 rij = zeros(Float64,3)
     7810 aij = zeros(Float64,3)
     7810 coeff = alpha*h^3/96*2*GNEWT
    54670 fac = 0.0; fac1 = 0.0; fac2 = 0.0; fac3 = 0.0; r1 = 0.0; r2 = 0.0; r3 = 0.0
     7810 for i=1:n-1
    54670   for j = i+1:n
   218680     for k=1:3
   656040       rij[k] = x[k,i] - x[k,j]
        -     end
   218680     r2 = rij[1]*rij[1]+rij[2]*rij[2]+rij[3]*rij[3]
   218680     r3 = r2*sqrt(r2)
   218680     for k=1:3
   656040       fac = GNEWT*rij[k]/r3
   656040       a[k,i] -= m[j]*fac
   656040       a[k,j] += m[i]*fac
        -       # Mass derivative of acceleration vector (10/6/17 notes):
        -       # Since there is no velocity dependence, this is fourth parameter.
        -       # Acceleration of ith particle depends on mass of jth particle:
   656040       dadq[k,i,4,j] -= fac
   656040       dadq[k,j,4,i] += fac
        -       # x derivative of acceleration vector:
   656040       fac *= 3.0/r2
        -       # Dot product x_ij.\delta x_ij means we need to sum over components:
   656040       for p=1:3
  1968120         dadq[k,i,p,i] += fac*m[j]*rij[p]
  1968120         dadq[k,i,p,j] -= fac*m[j]*rij[p]
  1968120         dadq[k,j,p,j] += fac*m[i]*rij[p]
  1968120         dadq[k,j,p,i] -= fac*m[i]*rij[p]
        -       end
        -       # Final term has no dot product, so just diagonal:
   656040       fac = GNEWT/r3
   656040       dadq[k,i,k,i] -= fac*m[j]
   656040       dadq[k,i,k,j] += fac*m[j]
   656040       dadq[k,j,k,j] -= fac*m[i]
   656040       dadq[k,j,k,i] += fac*m[i]
        -     end
        -   end
        - end
        - # Delete this when finished debugging:
        - #fill!(dadq,0.0)
        - # Next, compute \tilde g_i acceleration vector (this is rewritten
        - # slightly to avoid reference to \tilde a_i):
     7810 fill!(jac_step,0.0)
        - # Note that jac_step[(i-1)*7+k,(j-1)*7+p] is the derivative of the kth coordinate
        - # of planet i with respect to the pth coordinate of planet j.
     7810 for i=1:n-1
    54670   for j=i+1:n
   218680     for k=1:3
   656040       aij[k] = a[k,i] - a[k,j]
        - #      aij[k] = 0.0
   656040       rij[k] = x[k,i] - x[k,j]
        -     end
        -     # Compute dot product of r_ij with \delta a_ij:
   218680     fill!(dotdadq,0.0)
   218680     for d=1:n, p=1:4, k=1:3
 20993280       dotdadq[p,d] += rij[k]*(dadq[k,i,p,d]-dadq[k,j,p,d])
        -     end
   218680     r2 = rij[1]*rij[1]+rij[2]*rij[2]+rij[3]*rij[3]
   218680     r1 = sqrt(r2)
   218680     ardot = aij[1]*rij[1]+aij[2]*rij[2]+aij[3]*rij[3]
   218680     fac1 = coeff/r1^5
   218680     fac2 = (2*GNEWT*(m[i]+m[j])/r1 + 3*ardot) 
   218680     for k=1:3
        - #      fac = coeff/r1^5*(rij[k]*(2*GNEWT*(m[i]+m[j])/r1 + 3*ardot) - r2*aij[k])
   656040       fac = fac1*(rij[k]*fac2- r2*aij[k])
   656040       v[k,i] += m[j]*fac
   656040       v[k,j] -= m[i]*fac
        -       # Mass derivative (first part is easy):
   656040       jac_step[(i-1)*7+3+k,(j-1)*7+7] += fac
   656040       jac_step[(j-1)*7+3+k,(i-1)*7+7] -= fac
        -       # Position derivatives:
   656040       fac *= 5.0/r2
   656040       for p=1:3
  1968120         jac_step[(i-1)*7+3+k,(i-1)*7+p] -= fac*m[j]*rij[p]
  1968120         jac_step[(i-1)*7+3+k,(j-1)*7+p] += fac*m[j]*rij[p]
  1968120         jac_step[(j-1)*7+3+k,(j-1)*7+p] -= fac*m[i]*rij[p]
  1968120         jac_step[(j-1)*7+3+k,(i-1)*7+p] += fac*m[i]*rij[p]
        -       end
        -       # Second mass derivative:
   656040       fac = 2*GNEWT*fac1*rij[k]/r1
   656040       jac_step[(i-1)*7+3+k,(i-1)*7+7] += fac*m[j]
   656040       jac_step[(i-1)*7+3+k,(j-1)*7+7] += fac*m[j]
   656040       jac_step[(j-1)*7+3+k,(j-1)*7+7] -= fac*m[i]
   656040       jac_step[(j-1)*7+3+k,(i-1)*7+7] -= fac*m[i]
        -       #  (There's also a mass term in dadq [x]. See below.)
        -       # Diagonal position terms:
   656040       fac = fac1*fac2
   656040       jac_step[(i-1)*7+3+k,(i-1)*7+k] += fac*m[j]
   656040       jac_step[(i-1)*7+3+k,(j-1)*7+k] -= fac*m[j]
   656040       jac_step[(j-1)*7+3+k,(j-1)*7+k] += fac*m[i]
   656040       jac_step[(j-1)*7+3+k,(i-1)*7+k] -= fac*m[i]
        -       # Dot product \delta rij terms:
   656040       fac = -2*fac1*(rij[k]*GNEWT*(m[i]+m[j])/(r2*r1)+aij[k])
   656040       for p=1:3
  1968120         fac3 = fac*rij[p] + fac1*3.0*rij[k]*aij[p]
  1968120         jac_step[(i-1)*7+3+k,(i-1)*7+p] += m[j]*fac3
  1968120         jac_step[(i-1)*7+3+k,(j-1)*7+p] -= m[j]*fac3
  1968120         jac_step[(j-1)*7+3+k,(j-1)*7+p] += m[i]*fac3
  1968120         jac_step[(j-1)*7+3+k,(i-1)*7+p] -= m[i]*fac3
        -       end
        -       # Diagonal acceleration terms:
   656040       fac = -fac1*r2
        -       # Duoh.  For dadq, have to loop over all other parameters!
   656040       for d=1:n
  5248320         for p=1:3
 15744960           jac_step[(i-1)*7+3+k,(d-1)*7+p] += fac*m[j]*(dadq[k,i,p,d]-dadq[k,j,p,d])
 15744960           jac_step[(j-1)*7+3+k,(d-1)*7+p] -= fac*m[i]*(dadq[k,i,p,d]-dadq[k,j,p,d])
        -         end
        -         # Don't forget mass-dependent term:
  5248320         jac_step[(i-1)*7+3+k,(d-1)*7+7] += fac*m[j]*(dadq[k,i,4,d]-dadq[k,j,4,d])
  5248320         jac_step[(j-1)*7+3+k,(d-1)*7+7] -= fac*m[i]*(dadq[k,i,4,d]-dadq[k,j,4,d])
        -       end
        -       # Now, for the final term:  (\delta a_ij . r_ij ) r_ij
   656040       fac = 3.*fac1*rij[k]
   656040       for d=1:n
  5248320         for p=1:3
 15744960           jac_step[(i-1)*7+3+k,(d-1)*7+p] += fac*m[j]*dotdadq[p,d]
 15744960           jac_step[(j-1)*7+3+k,(d-1)*7+p] -= fac*m[i]*dotdadq[p,d]
        -         end
  5248320         jac_step[(i-1)*7+3+k,(d-1)*7+7] += fac*m[j]*dotdadq[4,d]
  5248320         jac_step[(j-1)*7+3+k,(d-1)*7+7] -= fac*m[i]*dotdadq[4,d]
        -       end
        -     end
        -   end
        - end
     7810 for i=1:n
    62480   for k=1:3
        -   # Position remains unchanged, so Jacobian of position should be identity matrix:
   187440     jac_step[(i-1)*7+  k,(i-1)*7+  k] += 1.0
        -   # Jacobian of velocity has linear dependence on initial velocity
   187440     jac_step[(i-1)*7+3+k,(i-1)*7+3+k] += 1.0
        -   end
        -   # Mass remains unchanged:
    62480   jac_step[(i-1)*7+7,(i-1)*7+7] += 1.0
        - end
     7810 return
        - end
        - 
        - # Carries out the DH17 mapping
        - function dh17!(x::Array{Float64,2},v::Array{Float64,2},h::Float64,m::Array{Float64,1},n::Int64)
   103860 alpha = alpha0
   103860 h2 = 0.5*h
        - # alpha = 0. is similar in precision to alpha=0.25
   103860 if alpha != 0.0
        0   phisalpha!(x,v,h,m,alpha,n)
        - end
   103860 drift!(x,v,h2,n)
   103860 for i=1:n-1
   727020   for j=i+1:n
  2908080     driftij!(x,v,i,j,-h2)
  2908080     keplerij!(m,x,v,i,j,h2)
        -   end
        - end
   103860 if alpha != 1.0
   103860   phisalpha!(x,v,h,m,2.*(1.-alpha),n)
        - end
   103860 for i=n-1:-1:1
   727020   for j=n:-1:i+1
  2908080     keplerij!(m,x,v,i,j,h2)
  2908080     driftij!(x,v,i,j,-h2)
        -   end
        - end
   103860 drift!(x,v,h2,n)
   103860 if alpha != 0.0
        0   phisalpha!(x,v,h,m,alpha,n)
        - end
   103860 return
        - end
        - 
        - # Used in computing the transit time:
        - function g!(i::Int64,j::Int64,x::Array{Float64,2},v::Array{Float64,2})
        - # See equation 8-10 Fabrycky (2008) in Seager Exoplanets book
   729178 g = (x[1,j]-x[1,i])*(v[1,j]-v[1,i])+(x[2,j]-x[2,i])*(v[2,j]-v[2,i])
   729178 return g
        - end
        - 
        - # Carries out the DH17 mapping & computes the jacobian:
        - function dh17!(x::Array{Float64,2},v::Array{Float64,2},h::Float64,m::Array{Float64,1},n::Int64,jac_step::Array{Float64,2})
     7811 h2 = 0.5*h
     7811 alpha = alpha0
     7811 jac_phi = zeros(Float64,7*n,7*n)
     7811 jac_tmp = zeros(Float64,7*n,7*n)
     7811 jac_step_ij = zeros(Float64,14,7*n)
        - # alpha = 0. is similar in precision to alpha=0.25
     7811 if alpha != 0.0
        0   phisalpha!(x,v,h,m,alpha,n,jac_phi)
        0   jac_step .= jac_phi*jac_step # < 1%
        - end
     7811 drift!(x,v,h2,n,jac_step)
     7811 jac_ij = zeros(Float64,14,14)
     7811 for i=1:n-1
    54676   for j=i+1:n
   218707     driftij!(x,v,i,j,-h2,jac_step,n)
   218707     keplerij!(m,x,v,i,j,h2,jac_ij) # 21%
   218706     for k1=1:7, k2=1:7*n
 85732752       jac_step_ij[  k1,k2]=jac_step[(i-1)*7+k1,k2]
 85732752       jac_step_ij[7+k1,k2]=jac_step[(j-1)*7+k1,k2]
        -     end
   218706     jac_step_ij .= *(jac_ij,jac_step_ij)
   218706     for k1=1:7, k2=1:7*n
 85732752       jac_step[(i-1)*7+k1,k2]=jac_step_ij[  k1,k2]
 85732752       jac_step[(j-1)*7+k1,k2]=jac_step_ij[7+k1,k2]
        -     end
        -   end
        - end
     7810 if alpha != 1.0
     7810   phisalpha!(x,v,h,m,2.*(1.-alpha),n,jac_phi) # 10%
     7810   jac_step .= jac_phi*jac_step # < 1%
        - end
     7810 for i=n-1:-1:1
    54670   for j=n:-1:i+1
   218680     keplerij!(m,x,v,i,j,h2,jac_ij) # 23%
   218680     for k2=1:7*n, k1=1:7
 85722560       jac_step_ij[  k1,k2]=jac_step[(i-1)*7+k1,k2]
 85722560       jac_step_ij[7+k1,k2]=jac_step[(j-1)*7+k1,k2]
        -     end
   218680     jac_step_ij .= *(jac_ij,jac_step_ij)
   218680     for k2=1:7*n, k1=1:7
 85722560       jac_step[(i-1)*7+k1,k2]=jac_step_ij[  k1,k2]
 85722560       jac_step[(j-1)*7+k1,k2]=jac_step_ij[7+k1,k2]
        -     end
   218680     driftij!(x,v,i,j,-h2,jac_step,n) 
        -   end
        - end
     7810 drift!(x,v,h2,n,jac_step)
     7810 if alpha != 0.0
        0   phisalpha!(x,v,h,m,alpha,n,jac_phi)
        0   jac_step .= jac_phi*jac_step # < 1%
        - end
     7810 return
        - end
        - 
        - function findtransit!(i,h,g1,g2,m,x1,v1,x2,v2)
        - # Computes the transit time, approximating the motion
        - # as a Keplerian forward & backward in time, weighted by location in the timestep.
        - # Initial guess using linear interpolation:
        - tt = -g1*h/(g2-g1)
        - dt = 1.0
        - 
        - # Setup state vectors for kepler_step:
        - s10 = zeros(Float64,12)
        - s20 = zeros(Float64,12)
        - # Final state (after a step):
        - s1 = zeros(Float64,12)
        - s2 = zeros(Float64,12)
        - s = zeros(Float64,12)
        - for k=1:NDIM
        -   s10[1+k     ] = x1[k,i] - x1[k,1]
        -   s10[1+k+NDIM] = v1[k,i] - v1[k,1]
        -   s20[1+k     ] = x2[k,i] - x2[k,1]
        -   s20[1+k+NDIM] = v2[k,i] - v2[k,1]
        - end
        - gm = GNEWT*(m[i]+m[1])
        - iter = 0
        - accel1= 0.
        - accel2= 0.
        - accel = zeros(Float64,3)
        - while abs(dt) > 1e-8 && iter < 20
        -   # Advance planet state at start of step to estimated transit time:
        -   kepler_step!(gm,    tt, s10, s1)
        -   # Reverse planet state at end of step to estimated transit time:
        -   kepler_step!(gm, -h+tt, s20, s2)
        -   # Weight:
        -   w = tt/h
        -   # Compute weighting of states:
        -   for j=2:7
        -     s[j] = (1.0-w)*s1[j]+w*s2[j]
        -   end
        -   # Compute time offset:
        -   g = s[2]*s[5]+s[3]*s[6]
        -   # Compute gravitational acceleration
        -   r1_3 = norm(s1[2:4])^3
        -   r2_3 = norm(s2[2:4])^3
        -   for k=1:3
        -     accel1 = -gm*s1[k+1]/r1_3
        -     accel2 = -gm*s2[k+1]/r2_3
        -     accel[k] = accel1*(1.0-w)+accel2*w
        -   end
        -   # Compute derivative of g with respect to time:
        -   gdot = s[5]^2+s[6]^2+s[2]*accel[1]+s[3]*accel[2]
        -   # Include time derivatives of interpolation (10/4/17 notes):
        -   gdot += ((s2[2]-s1[2])*s[5] + (s2[5]-s1[5])*s[2] +(s2[3]-s1[3])*s[6]+(s2[6]-s1[6])*s[3])/h
        -   # Refine estimate of transit time with Newton's method:
        -   dt = -g/gdot
        -   # Add refinement to estimated time:
        -   tt += dt
        -   iter +=1
        - end
        - # Note: this is the time elapsed *after* the beginning of the timestep:
        - return tt
        - end
        - 
        - function findtransit!(i,h,g1,g2,m,x1,v1,x2,v2,dtdqn)
        - # Computes the transit time, approximating the motion
        - # as a Keplerian forward & backward in time, weighted by location in the timestep.
        - # Initial guess using linear interpolation:
        - tt = -g1*h/(g2-g1)
        - dt = 1.0
        - 
        - # Vector for computing derivative with respect to the initial and final elements
        - # of the planet & star -  2 planets with 7 elements/masses at two times (initial & final):
        - dtdqn = zeros(7,2,2)
        - 
        - # Setup state vectors for kepler_step:
        - s10 = zeros(Float64,12)
        - s20 = zeros(Float64,12)
        - # Final state (after a step):
        - s1 = zeros(Float64,12)
        - s2 = zeros(Float64,12)
        - s = zeros(Float64,12)
        - for k=1:NDIM
        -   s10[1+k     ] = x1[k,i] - x1[k,1]
        -   s10[1+k+NDIM] = v1[k,i] - v1[k,1]
        -   s20[1+k     ] = x2[k,i] - x2[k,1]
        -   s20[1+k+NDIM] = v2[k,i] - v2[k,1]
        - end
        - gm = GNEWT*(m[i]+m[1])
        - iter = 0
        - accel1= 0.
        - accel2= 0.
        - accel = zeros(Float64,3)
        - while abs(dt) > 1e-8 && iter < 20
        -   # Advance planet state at start of step to estimated transit time:
        -   kepler_step!(gm,    tt, s10, s1)
        -   # Reverse planet state at end of step to estimated transit time:
        -   kepler_step!(gm, -h+tt, s20, s2)
        -   # Weight:
        -   w = tt/h
        -   # Compute weighting of states:
        -   for j=2:7
        -     s[j] = (1.0-w)*s1[j]+w*s2[j]
        -   end
        -   # Compute time offset:
        -   g = s[2]*s[5]+s[3]*s[6]
        -   # Compute gravitational acceleration
        -   r1_3 = norm(s1[2:4])^3
        -   r2_3 = norm(s2[2:4])^3
        -   for k=1:3
        -     accel1 = -gm*s1[k+1]/r1_3
        -     accel2 = -gm*s2[k+1]/r2_3
        -     accel[k] = accel1*(1.0-w)+accel2*w
        -   end
        -   # Compute derivative of g with respect to time:
        -   gdot = s[5]^2+s[6]^2+s[2]*accel[1]+s[3]*accel[2]
        -   # Include time derivatives of interpolation (10/4/17 notes):
        -   gdot += ((s2[2]-s1[2])*s[5] + (s2[5]-s1[5])*s[2] +(s2[3]-s1[3])*s[6]+(s2[6]-s1[6])*s[3])/h
        -   # Refine estimate of transit time with Newton's method:
        -   dt = -g/gdot
        -   # Add refinement to estimated time:
        -   tt += dt
        -   iter +=1
        - end
        - # Now compute derivative of transit time with respect to initial (& final)
        - # positions & masses of the planet/star:
        - 
        - 
        - # Note: this is the time elapsed *after* the beginning of the timestep:
        - return tt
        - end
        - 
        - function findtransit2!(i::Int64,j::Int64,h::Float64,tt::Float64,m::Array{Float64,1},x1::Array{Float64,2},v1::Array{Float64,2})
        - # Computes the transit time, approximating the motion as a fraction of a DH17 step forward in time.
        - # Initial guess using linear interpolation:
     3108 dt = 1.0
     3108 iter = 0
     3108 r3 = 0.0
     3108 gdot = 0.0
     3108 x = copy(x1)
     3108 v = copy(v1)
     3108 while abs(dt) > 1e-8 && iter < 20
     6067   x = copy(x1)
     6067   v = copy(v1)
        -   # Advance planet state at start of step to estimated transit time:
     6067   dh17!(x,v,tt,m,n)
        -   # Compute time offset:
     6067   gsky = g!(i,j,x,v)
        -   # Compute gravitational acceleration in sky plane dotted with sky position:
     6067   gdot = 0.0
     6067   for k=1:n
    48536     if k != i
    42469       r3 = sqrt((x[1,k]-x[1,i])^2+(x[2,k]-x[2,i])^2 +(x[3,k]-x[3,i])^2)^3
    42469       gdot += GNEWT*m[k]*((x[1,k]-x[1,i])*(x[1,j]-x[1,i])+(x[2,k]-x[2,i])*(x[2,j]-x[2,i]))/r3
        -     end
    48536     if k != j
    42469       r3 = sqrt((x[1,k]-x[1,j])^2+(x[2,k]-x[2,j])^2 +(x[3,k]-x[3,j])^2)^3
    42469       gdot -= GNEWT*m[k]*((x[1,k]-x[1,j])*(x[1,j]-x[1,i])+(x[2,k]-x[2,j])*(x[2,j]-x[2,i]))/r3
        -     end
        -   end
        -   # Compute derivative of g with respect to time:
     6067   gdot += (v[1,j]-v[1,i])^2+(v[2,j]-v[2,i])^2
        -   # Refine estimate of transit time with Newton's method:
     6067   dt = -gsky/gdot
        -   # Add refinement to estimated time:
     6067   tt += dt
     6067   iter +=1
        - end
        - # Compute derivatives:
        - #  dh17!(x,v,tt,m,n,jac_step)
        - # Note: this is the time elapsed *after* the beginning of the timestep:
     3108 return tt::Float64
        - end
        - 
        - function findtransit2!(i::Int64,j::Int64,h::Float64,tt::Float64,m::Array{Float64,1},x1::Array{Float64,2},v1::Array{Float64,2},jac_step::Array{Float64,2},dtdq::Array{Float64,2})
        - # Computes the transit time, approximating the motion as a fraction of a DH17 step forward in time.
        - # Also computes the Jacobian of the transit time with respect to the initial parameters, dtdq[7,n].
        - # Initial guess using linear interpolation:
      895 dt = 1.0
      895 iter = 0
      895 r3 = 0.0
      895 gdot = 0.0
      895 x = copy(x1)
      895 v = copy(v1)
      895 while abs(dt) > 1e-8 && iter < 20
     1790   x = copy(x1)
     1790   v = copy(v1)
        -   # Advance planet state at start of step to estimated transit time:
     1790   dh17!(x,v,tt,m,n)
        -   # Compute time offset:
     1790   gsky = g!(i,j,x,v)
        -   # Compute gravitational acceleration in sky plane dotted with sky position:
     1790   gdot = 0.0
     1790   for k=1:n
    14320     if k != i
    12530       r3 = sqrt((x[1,k]-x[1,i])^2+(x[2,k]-x[2,i])^2 +(x[3,k]-x[3,i])^2)^3
    12530       gdot += GNEWT*m[k]*((x[1,k]-x[1,i])*(x[1,j]-x[1,i])+(x[2,k]-x[2,i])*(x[2,j]-x[2,i]))/r3
        -     end
    14320     if k != j
    12530       r3 = sqrt((x[1,k]-x[1,j])^2+(x[2,k]-x[2,j])^2 +(x[3,k]-x[3,j])^2)^3
    12530       gdot -= GNEWT*m[k]*((x[1,k]-x[1,j])*(x[1,j]-x[1,i])+(x[2,k]-x[2,j])*(x[2,j]-x[2,i]))/r3
        -     end
        -   end
        -   # Compute derivative of g with respect to time:
     1790   gdot += (v[1,j]-v[1,i])^2+(v[2,j]-v[2,i])^2
        -   # Refine estimate of transit time with Newton's method:
     1790   dt = -gsky/gdot
        -   # Add refinement to estimated time:
     1790   tt += dt
     1790   iter +=1
        - end
        - # Compute time derivatives:
      895 x = copy(x1)
      895 v = copy(v1)
        - # Compute dgdt with the updated time step.
      895 dh17!(x,v,tt,m,n,jac_step)
        - # Compute time offset:
      895 gsky = g!(i,j,x,v)
        - # Compute gravitational acceleration in sky plane dotted with sky position:
      895 gdot = 0.0
      895 for k=1:n
     7160   if k != i
     6265     r3 = sqrt((x[1,k]-x[1,i])^2+(x[2,k]-x[2,i])^2 +(x[3,k]-x[3,i])^2)^3
     6265     gdot += GNEWT*m[k]*((x[1,k]-x[1,i])*(x[1,j]-x[1,i])+(x[2,k]-x[2,i])*(x[2,j]-x[2,i]))/r3
        -   end
     7160   if k != j
     6265     r3 = sqrt((x[1,k]-x[1,j])^2+(x[2,k]-x[2,j])^2 +(x[3,k]-x[3,j])^2)^3
     6265     gdot -= GNEWT*m[k]*((x[1,k]-x[1,j])*(x[1,j]-x[1,i])+(x[2,k]-x[2,j])*(x[2,j]-x[2,i]))/r3
        -   end
        - end
        - # Compute derivative of g with respect to time:
      895 gdot += (v[1,j]-v[1,i])^2+(v[2,j]-v[2,i])^2
        - # Set dtdq to zero:
      895 fill!(dtdq,0.0)
      895 for k=1:7
     6265   for p=1:n
        -     # Compute derivatives:
    50120     indj = (j-1)*7+1
    50120     indi = (i-1)*7+1
    50120     indp = (p-1)*7
    50120     dtdq[k,p] = -((jac_step[indj,indp+k]-jac_step[indi,indp+k])*(v[1,j]-v[1,i])+(jac_step[indj+1,indp+k]-jac_step[indi+1,indp+k])*(v[2,j]-v[2,i])+
        -                   (jac_step[indj+3,indp+k]-jac_step[indi+3,indp+k])*(x[1,j]-x[1,i])+(jac_step[indj+4,indp+k]-jac_step[indi+4,indp+k])*(x[2,j]-x[2,i]))/gdot
        -   end
        - end
        - # Note: this is the time elapsed *after* the beginning of the timestep:
      895 return tt::Float64
        - end
        - 
