        - # Wisdom & Hernandez version of Kepler solver, but with quartic
        - # convergence.
        - 
        - function calc_ds_opt(y,yp,ypp,yppp)
        - # Computes quartic Newton's update to equation y=0 using first through 3rd derivatives.
        - # Uses techniques outlined in Murray & Dermott for Kepler solver.
        - # Rearrange to reduce number of divisions:
 15120033 num = y*yp
 15120033 den1 = yp*yp-y*ypp*.5
 15120033 den12 = den1*den1
 15120033 den2 = yp*den12-num*.5*(ypp*den1-third*num*yppp)
 15120033 return -y*den12/den2
        - end
        - 
        - function kep_elliptic!(x0::Array{Float64,1},v0::Array{Float64,1},r0::Float64,dr0dt::Float64,k::Float64,h::Float64,beta0::Float64,s0::Float64,state::Array{Float64,1})
        - # Solves equation (35) from Wisdom & Hernandez for the elliptic case.
        - 
  1516004 r0inv = inv(r0)
  1516004 beta0inv = inv(beta0)
        - # Now, solve for s in elliptical Kepler case:
  1516004 if beta0 > 0.0
        - # Initial guess (if s0 = 0):
  1516004   if s0 == 0.0
  1516004     s = h*r0inv
        -   else
        0     s = copy(s0)
        -   end
  1516004   s0 = copy(s)
  1516004   sqb = sqrt(beta0)
  3032008   y = 0.0; yp = 1.0
  1516004   iter = 0
  1516004   ds = Inf
  1516004   fac1 = k-r0*beta0
  1516004   fac2 = r0*dr0dt
  1516004   while iter == 0 || (abs(ds) > KEPLER_TOL && iter < 10)
  2995103     xx = sqb*s
  2995103     sx = sqb*sin(xx)
  2995103     cx = cos(xx)
        - # Third derivative:
  2995103     yppp = fac1*cx - fac2*sx
        - # Take derivative:
  2995103     yp = (-yppp+ k)*beta0inv
        - # Second derivative:
  2995103     ypp = fac1*beta0inv*sx + fac2*cx
  2995103     y  = (-ypp + fac2 +k*s)*beta0inv - h  # eqn 35
        - # Now, compute fourth-order estimate:
  2995103     ds = calc_ds_opt(y,yp,ypp,yppp)
  2995103     s += ds
  2995103     iter +=1
        - #    println(iter," ds: ",ds)
        -   end
        - #  if iter > 1
        - #    println(iter," ",s," ",s/s0-1," ds: ",ds)
        - #  end
        - # Since we updated s, need to recompute:
  4548012   xx = 0.5*sqb*s; sx = sin(xx) ; cx = cos(xx)
        - # Now, compute final values:
  1516004   g1bs = 2.*sx*cx/sqb
  1516004   g2bs = 2.*sx^2*beta0inv
  1516004   f = 1.0 - k*r0inv*g2bs # eqn (25)
  1516004   g = r0*g1bs + fac2*g2bs # eqn (27)
  1516004   for j=1:3
        - # Position is components 2-4 of state:
  4548012     state[1+j] = x0[j]*f+v0[j]*g
        -   end
  1516004   r = sqrt(state[2]*state[2]+state[3]*state[3]+state[4]*state[4])
  1516004   rinv = inv(r)
  1516004   dfdt = -k*g1bs*rinv*r0inv
  1516004   dgdt = r0*(1.0-beta0*g2bs+dr0dt*g1bs)*rinv
  1516004   for j=1:3
        - # Velocity is components 5-7 of state:
  4548012     state[4+j] = x0[j]*dfdt+v0[j]*dgdt
        -   end
        - else
        0   println("Not elliptic ",beta0," x0 ",x0)
        - end
        - # recompute beta:
  1516004 state[8]= r
  1516004 state[9] = (state[2]*state[5]+state[3]*state[6]+state[4]*state[7])*rinv
        - # beta is element 10 of state:
  1516004 state[10] = 2.0*k*rinv-(state[5]*state[5]+state[6]*state[6]+state[7]*state[7])
        - # s is element 11 of state:
  1516004 state[11] = s
        - # ds is element 12 of state:
  1516004 state[12] = ds
  1516004 return iter
        - end
        - 
        - function kep_elliptic!(x0::Array{Float64,1},v0::Array{Float64,1},r0::Float64,dr0dt::Float64,k::Float64,h::Float64,beta0::Float64,s0::Float64,state::Array{Float64,1},jacobian::Array{Float64,2})
        - # Computes the Jacobian as well
        - # Solves equation (35) from Wisdom & Hernandez for the elliptic case.
        - 
   379554 r0inv = inv(r0)
   379554 beta0inv = inv(beta0)
        - # Now, solve for s in elliptical Kepler case:
   379554 if beta0 > 0.0
        - # Initial guess (if s0 = 0):
   379554   if s0 == 0.0
   379554     s = h*r0inv
        -   else
        0     s = copy(s0)
        -   end
   379554   s0 = copy(s)
   379554   sqb = sqrt(beta0)
   759108   y = 0.0; yp = 1.0
   379554   iter = 0
   379554   ds = Inf
   379554   fac1 = k-r0*beta0
   379554   fac2 = r0*dr0dt
   379554   while iter == 0 || (abs(ds) > KEPLER_TOL && iter < 10)
   757962     xx = sqb*s
   757962     sx = sqb*sin(xx)
   757962     cx = cos(xx)
        - # Third derivative:
   757962     yppp = fac1*cx - fac2*sx
        - # Take derivative:
   757962     yp = (-yppp+ k)*beta0inv
        - # Second derivative:
   757962     ypp = fac1*beta0inv*sx + fac2*cx
   757962     y  = (-ypp + fac2 +k*s)*beta0inv - h  # eqn 35
        - # Now, compute fourth-order estimate:
   757962     ds = calc_ds_opt(y,yp,ypp,yppp)
   757962     s += ds
   757962     iter +=1
        - #    println(iter," ds: ",ds)
        -   end
        - #  if iter > 1
        - #    println(iter," ",s," ",s/s0-1," ds: ",ds)
        - #  end
        - # Since we updated s, need to recompute:
  1138662   xx = 0.5*sqb*s; sx = sin(xx) ; cx = cos(xx)
        - # Now, compute final values:
   379554   g1bs = 2.*sx*cx/sqb
   379554   g2bs = 2.*sx^2*beta0inv
   379554   f = 1.0 - k*r0inv*g2bs # eqn (25)
   379554   g = r0*g1bs + fac2*g2bs # eqn (27)
   379554   for j=1:3
        - # Position is components 2-4 of state:
  1138662     state[1+j] = x0[j]*f+v0[j]*g
        -   end
   379554   r = sqrt(state[2]*state[2]+state[3]*state[3]+state[4]*state[4])
   379554   rinv = inv(r)
   379554   dfdt = -k*g1bs*rinv*r0inv
   379554   dgdt = r0*(1.0-beta0*g2bs+dr0dt*g1bs)*rinv
   379554   for j=1:3
        - # Velocity is components 5-7 of state:
  1138662     state[4+j] = x0[j]*dfdt+v0[j]*dgdt
        -   end
        - # Now, compute the jacobian:
   379554   fill!(jacobian,0.0)
   379554   compute_jacobian!(h,k,x0,v0,beta0,s,f,g,dfdt,dgdt,cx,sx,g1bs,g2bs,r0,dr0dt,r,jacobian)
        - else
        0   println("Not elliptic ",beta0," x0 ",x0)
        - end
        - # recompute beta:
   379554 state[8]= r
   379554 state[9] = (state[2]*state[5]+state[3]*state[6]+state[4]*state[7])*rinv
        - # beta is element 10 of state:
   379554 state[10] = 2.0*k*rinv-(state[5]*state[5]+state[6]*state[6]+state[7]*state[7])
        - # s is element 11 of state:
   379554 state[11] = s
        - # ds is element 12 of state:
   379554 state[12] = ds
        - # Compute the Jacobian.  jacobian[i,j] is derivative of final state variable q[i]
        - # with respect to initial state variable q0[j], where q = {x,v} & q0 = {x0,v0}.
        - 
   379554 return iter
        - end
        - 
        - function kep_hyperbolic!(x0::Array{Float64,1},v0::Array{Float64,1},r0::Float64,dr0dt::Float64,k::Float64,h::Float64,beta0::Float64,s0::Float64,state::Array{Float64,1})
        - # Solves equation (35) from Wisdom & Hernandez for the hyperbolic case.
        - 
  4548012 r0inv = inv(r0)
  4548012 beta0inv = inv(beta0)
        - # Now, solve for s in hyperbolic Kepler case:
  4548012 if beta0 < 0.0
        - # Initial guess (if s0 = 0):
  4548012   if s0 == 0.0
  4548012     s = h*r0inv
        -   else
        0     s = copy(s0)
        -   end
  4548012   s0 = copy(s)
  4548012   sqb = sqrt(-beta0)
  9096024   y = 0.0; yp = 1.0
  4548012   iter = 0
  4548012   ds = Inf
  4548012   fac1 = k-r0*beta0
  4548012   fac2 = r0*dr0dt
  4548012   while iter == 0 || (abs(ds) > KEPLER_TOL && iter < 10)
 27270282     xx = sqb*s; cx = cosh(xx); sx = sqb*(exp(xx)-cx)
        - # Third derivative:
  9090094     yppp = fac1*cx + fac2*sx
        - # Take derivative:
  9090094     yp = (-yppp+ k)*beta0inv
        - # Second derivative:
  9090094     ypp = -fac1*beta0inv*sx  + fac2*cx
  9090094     y  = (-ypp +fac2 +k*s)*beta0inv - h  # eqn 35
        - # Now, compute fourth-order estimate:
  9090094     ds = calc_ds_opt(y,yp,ypp,yppp)
  9090094     s += ds
  9090094     iter +=1
        - #    println(iter," ds: ",ds)
        -   end
        - #  if iter > 1
        - #    #println("iter: ",iter," ds/s: ",ds/s0)
        - #    println(iter," ",s," ",s/s0-1," ds: ",ds)
        - #  end
 13644036   xx = 0.5*sqb*s; cx = cosh(xx); sx = exp(xx)-cx
        - # Now, compute final values:
  4548012   g1bs = 2.0*sx*cx/sqb
  4548012   g2bs = -2.0*sx^2*beta0inv
  4548012   f = 1.0 - k*r0inv*g2bs # eqn (25)
  4548012   g = r0*g1bs + fac2*g2bs # eqn (27)
  4548012   for j=1:3
 13644036     state[1+j] = x0[j]*f+v0[j]*g
        -   end
        -   # r = norm(x)
  4548012   r = sqrt(state[2]*state[2]+state[3]*state[3]+state[4]*state[4])
  4548012   rinv = inv(r)
  4548012   dfdt = -k*g1bs*rinv*r0inv
  4548012   dgdt = r0*(1.0-beta0*g2bs+dr0dt*g1bs)*rinv
  4548012   for j=1:3
        - # Velocity is components 5-7 of state:
 13644036     state[4+j] = x0[j]*dfdt+v0[j]*dgdt
        -   end
        - else
        0   println("Not hyperbolic",beta0," x0 ",x0)
        - end
        - # recompute beta:
  4548012 state[8]= r
  4548012 state[9] = (state[2]*state[5]+state[3]*state[6]+state[4]*state[7])*rinv
        - # beta is element 10 of state:
  4548012 state[10] = 2.0*k*rinv-(state[5]*state[5]+state[6]*state[6]+state[7]*state[7])
        - # s is element 11 of state:
  4548012 state[11] = s
        - # ds is element 12 of state:
  4548012 state[12] = ds
  4548012 return iter
        - end
        - 
        - function kep_hyperbolic!(x0::Array{Float64,1},v0::Array{Float64,1},r0::Float64,dr0dt::Float64,k::Float64,h::Float64,beta0::Float64,s0::Float64,state::Array{Float64,1},jacobian::Array{Float64,2})
        - # Solves equation (35) from Wisdom & Hernandez for the hyperbolic case.
        - 
  1138662 r0inv = inv(r0)
  1138662 beta0inv = inv(beta0)
        - # Now, solve for s in hyperbolic Kepler case:
  1138662 if beta0 < 0.0
        - # Initial guess (if s0 = 0):
  1138662   if s0 == 0.0
  1138662     s = h*r0inv
        -   else
        0     s = copy(s0)
        -   end
  1138662   s0 = copy(s)
  1138662   sqb = sqrt(-beta0)
  2277324   y = 0.0; yp = 1.0
  1138662   iter = 0
  1138662   ds = Inf
  1138662   fac1 = k-r0*beta0
  1138662   fac2 = r0*dr0dt
  1138662   while iter == 0 || (abs(ds) > KEPLER_TOL && iter < 10)
  6830622     xx = sqb*s; cx = cosh(xx); sx = sqb*(exp(xx)-cx)
        - # Third derivative:
  2276874     yppp = fac1*cx + fac2*sx
        - # Take derivative:
  2276874     yp = (-yppp+ k)*beta0inv
        - # Second derivative:
  2276874     ypp = -fac1*beta0inv*sx  + fac2*cx
  2276874     y  = (-ypp +fac2 +k*s)*beta0inv - h  # eqn 35
        - # Now, compute fourth-order estimate:
  2276874     ds = calc_ds_opt(y,yp,ypp,yppp)
  2276874     s += ds
  2276874     iter +=1
        - #    println(iter," ds: ",ds)
        -   end
        - #  if iter > 1
        - #    #println("iter: ",iter," ds/s: ",ds/s0)
        - #    println(iter," ",s," ",s/s0-1," ds: ",ds)
        - #  end
  3415986   xx = 0.5*sqb*s; cx = cosh(xx); sx = exp(xx)-cx
        - # Now, compute final values:
  1138662   g1bs = 2.0*sx*cx/sqb
  1138662   g2bs = -2.0*sx^2*beta0inv
  1138662   f = 1.0 - k*r0inv*g2bs # eqn (25)
  1138662   g = r0*g1bs + fac2*g2bs # eqn (27)
  1138662   for j=1:3
  3415986     state[1+j] = x0[j]*f+v0[j]*g
        -   end
        -   # r = norm(x)
  1138662   r = sqrt(state[2]*state[2]+state[3]*state[3]+state[4]*state[4])
  1138662   rinv = inv(r)
  1138662   dfdt = -k*g1bs*rinv*r0inv
  1138662   dgdt = r0*(1.0-beta0*g2bs+dr0dt*g1bs)*rinv
  1138662   for j=1:3
        - # Velocity is components 5-7 of state:
  3415986     state[4+j] = x0[j]*dfdt+v0[j]*dgdt
        -   end
        - # Now, compute the jacobian:
  1138662   fill!(jacobian,0.0)
  1138662   compute_jacobian!(h,k,x0,v0,beta0,s,f,g,dfdt,dgdt,cx,sx,g1bs,g2bs,r0,dr0dt,r,jacobian)
        - else
        0   println("Not hyperbolic",beta0," x0 ",x0)
        - end
        - # recompute beta:
  1138662 state[8]= r
  1138662 state[9] = (state[2]*state[5]+state[3]*state[6]+state[4]*state[7])*rinv
        - # beta is element 10 of state:
  1138662 state[10] = 2.0*k*rinv-(state[5]*state[5]+state[6]*state[6]+state[7]*state[7])
        - # s is element 11 of state:
  1138662 state[11] = s
        - # ds is element 12 of state:
  1138662 state[12] = ds
  1138662 return iter
        - end
        - 
        - function compute_jacobian!(h::Float64,k::Float64,x0::Array{Float64,1},v0::Array{Float64,1},beta0::Float64,s::Float64,f::Float64,g::Float64,dfdt::Float64,dgdt::Float64,cx::Float64,sx::Float64,g1::Float64,g2::Float64,r0::Float64,dr0dt::Float64,r::Float64,jacobian::Array{Float64,2})
        - # Compute the Jacobian.  jacobian[i,j] is derivative of final state variable q[i]
        - # with respect to initial state variable q0[j], where q = {x,v,k} & q0 = {x0,v0,k}.
        - # Now, compute the Jacobian: (9/18/2017 notes)
        - #g0 = cx^2-sx^2
  1518216 g0 = 1.0-beta0*g2
  1518216 g3 = (s-g1)/beta0
  1518216 dotalpha0 = r0*dr0dt  # unnecessary to divide by r0 for dr0dt & multiply for \dot\alpha_0
  1518216 absv0 = sqrt(dot(v0,v0))
  1518216 dsdbeta = (2h-r0*(s*g0+g1)+k/beta0*(s*g0-g1)-dotalpha0*s*g1)/(2beta0*r)
  1518216 dsdr0 = -(2k/r0^2*dsdbeta+g1/r)
  1518216 dsda0 = -g2/r
  1518216 dsdv0 = -2absv0*dsdbeta
  1518216 dsdk = 2/r0*dsdbeta-g3/r
  1518216 dbetadr0 = -2k/r0^2
  1518216 dbetadv0 = -2absv0
  1518216 dbetadk  = 2/r0
        - # "p" for partial derivative:
        - #pxpr0 = zeros(Float64,3); pxpa0=zeros(Float64,3); pxpk=zeros(Float64,3); pxps=zeros(Float64,3); pxpbeta=zeros(Float64,3)
        - #dxdr0 = zeros(Float64,3); dxda0=zeros(Float64,3); dxdk=zeros(Float64,3); dxdv0 =zeros(Float64,3)
        - #prvpr0 = zeros(Float64,3); prvpa0=zeros(Float64,3); prvpk=zeros(Float64,3); prvps=zeros(Float64,3); prvpbeta=zeros(Float64,3)
        - #drvdr0 = zeros(Float64,3); drvda0=zeros(Float64,3); drvdk=zeros(Float64,3); drvdv0=zeros(Float64,3)
        - #vtmp = zeros(Float64,3); dvdr0 = zeros(Float64,3); dvda0=zeros(Float64,3); dvdv0=zeros(Float64,3); dvdk=zeros(Float64,3)
  1518216 for i=1:3
  4554648   pxpr0[i] = k/r0^2*g2*x0[i]+g1*v0[i]
  4554648   pxpa0[i] = g2*v0[i]
  4554648   pxpk[i]  = -g2/r0*x0[i]
  4554648   pxps[i]  = -k/r0*g1*x0[i]+(r0*g0+dotalpha0*g1)*v0[i]
  4554648   pxpbeta[i] = -k/(2beta0*r0)*(s*g1-2g2)*x0[i]+1/(2beta0)*(s*r0*g0-r0*g1+s*dotalpha0*g1-2*dotalpha0*g2)*v0[i]
  4554648   prvpr0[i] = k*g1/r0^2*x0[i]+g0*v0[i]
  4554648   prvpa0[i] = g1*v0[i]
  4554648   prvpk[i] = -g1/r0*x0[i]
  4554648   prvps[i] = -k*g0/r0*x0[i]+(-beta0*r0*g1+dotalpha0*g0)*v0[i]
  4554648   prvpbeta[i] = -k/(2beta0*r0)*(s*g0-g1)*x0[i]+1/(2beta0)*(-s*r0*beta0*g1+dotalpha0*s*g0-dotalpha0*g1)*v0[i]
        - end
  1518216 prpr0 = g0
  1518216 prpa0 = g1
  1518216 prpk  = g2
  1518216 prps = (k-beta0*r0)*g1+dotalpha0*g0
  1518216 prpbeta = 1/(2beta0)*(s*(k-beta0*r0)*g1+dotalpha0*s*g0-dotalpha0*g1-2k*g2)
  1518216 for i=1:3
  4554648   dxdr0[i] = pxps[i]*dsdr0 + pxpbeta[i]*dbetadr0 + pxpr0[i]
  4554648   dxda0[i] = pxps[i]*dsda0 + pxpa0[i]
  4554648   dxdv0[i] = pxps[i]*dsdv0 + pxpbeta[i]*dbetadv0
  4554648   dxdk[i]  = pxps[i]*dsdk  + pxpbeta[i]*dbetadk + pxpk[i]
  4554648   drvdr0[i] = prvps[i]*dsdr0 + prvpbeta[i]*dbetadr0 + prvpr0[i]
  4554648   drvda0[i] = prvps[i]*dsda0 + prvpa0[i]
  4554648   drvdv0[i] = prvps[i]*dsdv0 + prvpbeta[i]*dbetadv0
  4554648   drvdk[i]  = prvps[i]*dsdk  + prvpbeta[i]*dbetadk +prvpk[i]
        - end
  1518216 drdr0 = prpr0 + prps*dsdr0 + prpbeta*dbetadr0
  1518216 drda0 = prpa0 + prps*dsda0
  1518216 drdv0 = prps*dsdv0 + prpbeta*dbetadv0
  1518216 drdk  = prpk + prps*dsdk + prpbeta*dbetadk
  1518216 for i=1:3
  4554648   vtmp[i] = dfdt*x0[i]+dgdt*v0[i]
  4554648   dvdr0[i] = (drvdr0[i]-drdr0*vtmp[i])/r
  4554648   dvda0[i] = (drvda0[i]-drda0*vtmp[i])/r
  4554648   dvdv0[i] = (drvdv0[i]-drdv0*vtmp[i])/r
  4554648   dvdk[i]  = (drvdk[i] -drdk *vtmp[i])/r
        - end
        - # Now, compute Jacobian:
  1518216 for i=1:3
  4554648   jacobian[  i,  i] = f
  4554648   jacobian[  i,3+i] = g
  4554648   jacobian[3+i,  i] = dfdt
  4554648   jacobian[3+i,3+i] = dgdt
  4554648   jacobian[  i,7] = dxdk[i]
  4554648   jacobian[3+i,7] = dvdk[i]
        - end
  1518216 for j=1:3
  4554648   for i=1:3
 13663944     jacobian[  i,  j] += dxdr0[i]*x0[j]/r0 + dxda0[i]*v0[j]
 13663944     jacobian[  i,3+j] += dxdv0[i]*v0[j]/absv0 + dxda0[i]*x0[j]
 13663944     jacobian[3+i,  j] += dvdr0[i]*x0[j]/r0 + dvda0[i]*v0[j]
 13663944     jacobian[3+i,3+j] += dvdv0[i]*v0[j]/absv0 + dvda0[i]*x0[j]
        -   end
        - end
  1518216 jacobian[7,7]=1.0
  1518216 return
        - end
        - 
