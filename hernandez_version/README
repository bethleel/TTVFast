8/9/17
Implementing Wisdom & Hernandez (2015) Universal Kepler solver.

So far it doesn't seem to converge as fast as a standard Kepler
solver for the elliptic case.

8/9/17
Okay, elliptic case seems to work, and one iteration of quartic
extrapolation gets me within ~machine precision!

Now for hyperbolic case...  I need to rederive everything.
WH's small-angle concern I don't think is a big issue in practice
(of course, unless there is a large period ratio so that outer
planets have to take small steps... maybe I should stick to
half-angles).

Also need to code up parabolic case (cubic equation):

y(s) = s^3 + 3*r0*s^2*dr0dt/k + 6r0*s/k -6h/k
     = s^3 + a s^2 + b s + c
   with a = 3*r0*dr0dt/k, b=6*r0/k, c = -6h/k

Q = r0^2*dr0dt^2/k^2 - 2r0/k
R = r0^3*dr0dt^3/k^3 - 3*r0^2*dr0dt/k^2 - 3*h/k

Q: If there are three real roots, which one do we choose?

8/10/2017
Okay, I got the hyperbolic case working!

Now, for the parabolic (although this should almost never occur in practice...).

Problem: quickly get NaNs since beta becomes slightly less than
zero (presumably due to rounding error).

Okay, got parabolic case working.  It is called if beta is within ~10^{-15}
of zero.

8/11/2017
Not sure what is going on with allocations...  this seems to always
trip me up.  Dan figured out how to rewrite celerite without as
much memory allocation;  it might be worth looking at that code.

10^6 steps in 4-5 seconds;  not great compared with what Hernandez finds.
Wonder if this is related to the memory allocation problem?

8/12/2017
Why is test_elliptic getting zeros back for r & beta_final???!

Julia is a mystery...

8/12/2017
test_elliptic.jl gives ~0.2 \mu sec for each call to kepler_solver_elliptic.
For 800 days of trappist-1, this gives ~800/1.5*20*28*2e-7 ~ 0.06 sec; not
great.... plus, this could be higher since FB algorithm takes steps
back & forth, and there may be more than one iteration in some cases.

8/14/2017
Okay, so I have some problems with Julia:
1).  If I pass out a tuple, then this is handled with type-unstable operations, slowing things down.
2).  If there are variables which I pass through, then these are type-unstable.
3).  But, otherwise I need to define new variables in the routine, which takes overhead.

I tried using a Type to bundle these, but then I need to instantiate the type within the
routine, which takes too much time.

There has to be some way to pre-allocate variables for Julia so I don't have to waste time
defining variables all of the time!

Okay, so I settled on passing a state vector - this avoids the need to define a new type -
and then I just save the final state at the end of the step to this vector.  Not as elegant
or readable, but it's the fastest yet: 0.2 microseconds per Kepler step (one iteration).

8/15/2017

I corrected a mistake in comp_ds_opt, and made some other other changes
to decrease the number of operations.  Reduced speed by ~10%.

When I take larger timesteps, the total run time doesn't grow significantly
with two iterations per step.

I wonder if it would be quicker to solve cubic equation for the initial step guess? [ ]

Okay, I've rewritten kepler_solver_hyperbolic.jl, and now combined
kepler_solver_elliptic.jl and kepler_solver_hyperbolic.jl into kepler_solver.jl
(they use the function in common calc_cs_opt).

Both seem to preserve beta well, and take about 0.3 microseconds for each step
when the eccentricity is modest!

Onward to carrying out symplectic integrator:

1). Figure out COM coordinates & drift operations.
2). Figure out how to compute whether a transit has occured.
3). Figure out cartesian coordinates.
4). Write the basic operator code for a pair of planets.

8/30/2017

1). See whether I can reproduce Hernandez' code in Julia, and try out the
eccentric binary planet problem. [x]
2). Does cubic initial estimate speed things up, or slow it down? [ ]
3). Then, figure out TTVs and benchmark. [ ]

Then, try it out for a planet-moon system orbiting a binary star! [ ]

Okay, I've translated nbody.c to nbody.jl (with a bit more work needed for the
main function).  Next, I need to try running to see if it gives same results with
my Kepler solver!

8/31/2017
Okay, I got the Julia translation done.  Now for debugging next!

Code seems to be debugged, and agrees (for the most part) with David's. [x]

Next, I need to
1). Add in extrapolation of s from prior steps; [ ]
2). Enable finding transit times; [x]
3). Set up initial conditions. [x]
    - This involves coming up with a means of specifying a hierarchical N-body system.
Then, take derivatives, and optimize fits to T-1!

9/5/2017

Okay, now I need to set up the initial conditions.  I'm planning
to use the parentheses notation from Milani & Nobili (1983),
and to use the matrix notation of Hamers & Portegies Zwart (2016).

Tasks:
1).  Parse the hierarchy.  [x] (sort of - just for planetary configuration)
2).  Compute the A matrix. [x]
3).  Invert the matrix.    [x]
4).  Compute the semi-major axis for each Kepler problem. [x]
5).  Compute the cartesian elements & velocities for each Keplerian. [x]
6).  Compute the initial positions & velocities. [x]
7).  Couple to the integrator. [x]
8).  Compute transit times. [x]

9/7/2017
Problem: consq! isn't modifying L0, p0 or xcm0.
Solution: switched to fill! rather than zeros(NDIM) in consq!

Now, it seems to be working!  Energy is conserved to ~4x10^-7 for a step size
of 0.15 days.

Idea:  Make a plot of the barycentric motion of the star with time. [x]

This looks pretty cool!

9/8/2017
Okay, got a routine working which computes TTVs, and they look qualitatively
similar to Simon Grimm's code(!).

Next steps:
1).  Optimize code, and figure out some way to check that it is working correctly.
2).  Compute transit time derivatives with respect to initial elements
(either analytically, or with autodiff).
3).  Optimize the fit to the latest transit times for the paper.
4).  Figure out how to run a Markov chain.

Checking the convergence with time step, there appear to be (t0,P) offsets
(possibly because there is no corrector applied for the integrator), but
for TRAPPIST-1, the TTV appear to be converged to <3 sec precision for
a time step of 0.05 days (about 1/30 of the period of the inner planet).
This should be sufficient given the precision of the measurements.

Right now the run time is prohibitively slow!  0.4 seconds... and there doesn't
appear to be much to optimize - the profile looked fairly clean.  I could possibly
get another factor of 2 in speed-up if I implement the extrapolation of s, and
if I can converge in ~1 iteration rather than two. [ ]  Another possibility would
be to only include adjacent planets' perturbations, which may give another
factor of ~2.8 speed-up. [ ]  I should also figure out how long the transit-time
computation is taking:  in practice I'll only need to compute the observed
transit times, which may save a bit. [ ] Overall, though, rather disappointing:  
I was hoping to obtain ~msec speed.

I need to see how long the other version(s) of TTVFast are taking, and I should also 
ask Simon how long his integrator takes. [ ]

Otherwise the only way to get additional speed is to figure out how to improve
TTVFaster (which seems impossible), or to figure out how to make TTVFast parallel
(also daunting).  Analytic derivatives may help with optimization, which I should
look into next, both with autodiff [ ] and with propagating derivative. [ ]

The other possibility is to compute a grid of models, and
to fit these with a quadratic function of the transit times.  This approach
seems promising, so I'll look into it next week. [ ]

I also need to look into the coordinate system to make sure I'm transforming
correctly. [ ]

Another to do: Figure out a corrector/inverse corrector for this map. [ ]

To do:
1). Compute derivatives.
2). Optimize model to TRAPPIST-1.
3). Perturb parameters; see if we can find a quadratic fit to transit times
as a function of the starting parameters.
4). With quadratic fit, carry out an MCMC analysis.

9/11/2017

Not much success with any of the next steps yet.

The initial times of transit seem to change wildly when the initial t_0 values
change by a small amount.  Perhaps I need to make sure that the t0 values are defined
early on.

Found a bug: omega was being converted to radians from degrees, while it was starting
in radians.  This helps to fix the starting t0; now this matches better.  I also
now define the t0 values close to the start of the integration.

Problem:  How do we carry out a linearization with respect to the initial parameters
while guaranteeing somehow that the transit times aren't too far off of the correct
values?  Should we try to expand in harmonics of adjacent planets?

9/12/2017

Next, going to try autodiff on the various functions, and see what it comes up with.

9/20/2017
I'm making progress on differentiable function...
